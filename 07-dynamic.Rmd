# Dynamic {#dynamic}

```{r, echo=FALSE, include=FALSE}
library(twinetverse)

TK <- readRDS("twitter_token.rds")
```

So far we have been drawing static graphs, in this chapter we look at dynamic ones, namely temporal. 

## Rationale

We've been visualising Twitter interactions in a static manner, but they are dynamic when you think of it. Twitter conversations happen over time, thus far, we've been drawing all encompassing snapshots. So let's take into account the time factor to make a tempral graphs.

## Collect

We'll collect some tweets again, but feel free to use previously collected tweets; nothing changes at this stage.

```{r, eval=TRUE}
# TK <- readRDS(file = "token.rds")
tweets <- search_tweets("#rstats filter:mentions", n = 5000, token = TK, include_rts = FALSE)
```

## Build

Now onto building the graph.

```{r, eval=TRUE}
net <- tweets %>% 
  gt_edges(text, screen_name, status_id, created_at = "created_at") %>% 
  gt_nodes() %>% 
  gt_dyn() %>% 
  gt_collect()
```

Quite a few things differ from previous graphs we have built.

1. We pass `created_at` in `gt_edges`. This in effect adds the `created_at` column to our edges, so that we know the created time of post in which the edge appears.
2. We use `gt_dyn` which stands for `dynamic`, which essentially computes the time at which edges and nodes should appear and disappear.

```{r, eval=FALSE}
head(net$edges)
```

```{r, eval=TRUE, echo = FALSE}
knitr::kable(head(net$edges))
```

## Visualise

Now for the visualisation, let's build it step by step; first we prep the data as we did before: renaming a few columns but also running a few unfamiliar computations. 

To explain we need to tackle how edges will dinamically appear on the graph. The way this works in sigmajs is by specifying the delay in milliseconds before each respective edge should be added. Therefore, we need to transform the date to milliseconds and rescale them to be within a reasonable range: we don't want the edges to actually take 15 days to appear on the graph.

1. We change the date (`POSIXct` actually) to a numeric which gives the number of milliseconds since 1970.
2. We rescale between 0 and 1 then multiply by 10,000 (milliseconds) so that the edges are added over 10 seconds.

```{r}
library(dplyr)

c(edges, nodes) %<-% net # unpack

nodes <- nodes2sg(nodes)

edges <- edges %>% 
  mutate(
    id = 1:n(),
    created_at = as.numeric(created_at),
    created_at = (created_at - min(created_at)) / (max(created_at) - min(created_at)),
    created_at = created_at * 10000
  ) %>% 
  select(id, source, target, created_at)
```

Now, the actual visualisation, as mentioned at the begining to the chapter, we'll plot the nodes then add edges dynamically. Let's break it down step by step. 

First, we plot the nodes.

```{r}
sigmajs() %>% 
  sg_nodes(nodes, id, size, label) 
```

We'll add the layout as it looks a bit messy with nodes randomly scattered across the canvas. We'll have to compute the layout differently this time, we cannot simply use `sg_layout` as it requires both nodes and edges and we only have nodes on the graph; instead we use `sg_get_layout`.

This is something that we had not shared with you earlier on, `sg_nodes` must have `x` and `y` coordinates of each node, however, if missing they are generated randomly by the package. We simply compute those coordinates then bind them to our nodes.

```{r, warning = FALSE, eval = FALSE}
layout <- sg_get_layout(nodes, edges)

nodes <- nodes %>% 
  bind_cols(layout)

head(nodes)
```

```{r, warning = FALSE, eval = TRUE, echo=FALSE}
layout <- sg_get_layout(nodes, edges)

nodes <- nodes %>% 
  bind_cols(layout)

knitr::kable(head(nodes))
```

Now we can simply pass the coordinates `x` and `y` to `sg_nodes`.

```{r}
sigmajs() %>% 
  sg_nodes(nodes, id, size, label, x, y) 
```

Let's beautify the graph a little, this deep black is somewhat unnerving.

```{r}
sigmajs() %>% 
  sg_nodes(nodes, id, size, label, x, y) %>%
  sg_settings(
    defaultNodeColor = "#127ba3",
    edgeColor = "default",
    defaultEdgeColor = "#d3d3d3",
    minNodeSize = 1,
    maxNodeSize = 4,
    minEdgeSize = 0.3,
    maxEdgeSize = 0.3
  )
```

Now we have something that looks like a graph, except it's missing edges. Let's add them.

We add the edges almost exactly as we did before, we use `sg_add_edges` instead of `sg_edges`. Other than the function name, the only difference is that we pass `created_at` as `delay`.

```{r}
sigmajs() %>% 
  sg_nodes(nodes, id, size, label, x, y) %>%
  sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %>% 
  sg_settings(
    defaultNodeColor = "#127ba3",
    edgeColor = "default",
    defaultEdgeColor = "#d3d3d3",
    minNodeSize = 1,
    maxNodeSize = 4,
    minEdgeSize = 0.3,
    maxEdgeSize = 0.3
  )
```

Now the edges appear dynamically. However **you probably missed that** as the animation is triggered when the page is loaded. sigmajs provides an easy workaround: we can add a button for the user to trigger the animation themself.

```{r}
sigmajs() %>% 
  sg_nodes(nodes, id, size, label, x, y) %>%
  sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %>% 
  sg_button("Add edges", "add_edges") %>% 
  sg_settings(
    defaultNodeColor = "#127ba3",
    edgeColor = "default",
    defaultEdgeColor = "#d3d3d3",
    minNodeSize = 1,
    maxNodeSize = 4,
    minEdgeSize = 0.3,
    maxEdgeSize = 0.3
  )
```


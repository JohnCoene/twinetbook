# Ephemeral {#ephemeral}

```{r, echo=FALSE, include=FALSE}
library(twinetverse)

TK <- readRDS("twitter_token.rds")
```

At this stage we've pretty much fully covered temporal graphs; nodes and edges appear over time on the graph. This already comes closer to reflecting reality if we assume that tweets are _everlasting_. In practice tweets have a life span; it is unlikely that old tweets from 2015 will be seen today. Therefore, on our graph, nodes and edges should appear then disappear after some time.

## Collect

Let's collect some tweets, just as we did previously.

```{r, eval=TRUE}
# TK <- readRDS(file = "token.rds")
tweets <- search_tweets("#rstats filter:mentions", n = 200, token = TK, include_rts = FALSE)
```

## Build

Just as we did in the [temporal](#temporal) chapter, we'll pass `created_at` so that we know when tweets are created (when edges and nodes should appear), with one difference: we specify `lifetime` in our `gt_dyn` function.

```{r, eval=TRUE}
net <- tweets %>% 
  gt_edges(text, screen_name, status_id, created_at = "created_at") %>% 
  gt_nodes() %>% 
  gt_dyn(60 * 60 * 6) %>% 
  gt_collect()
```

The `lifetime` argument takes milliseconds, above, we set it `60 * 60 * 6` which is equal to 6 hours. As you might expect, we will rescale the timeframe as we did before but here we set the lifetime of a tweet _before_ doing so.

So logically, if we take the difference between the appearance and the disappearance of an edge we should obtain 6 hours.

```{r, warning = FALSE, eval = TRUE}
c(edges, nodes) %<-% net

edges$difference <- edges$end - edges$created_at
head(edges)
```

```{r, warning = FALSE, eval = TRUE, echo=FALSE}
knitr::kable(head(edges))
```

But how would this apply to nodes? Let's plot the distribution of the lifespans of nodes (in milliseconds): the difference between their appearance and disappearance.

```{r, warning = FALSE, eval = TRUE}
nodes$difference <- as.numeric(nodes$end - nodes$start)
hist(
  main = "Distribution of nodes lifespan",
  nodes$difference
)
```

We see that, _unlike edges_ nodes are not all present on the graph for the same amount of time (6 hours for edges). There is a simple reason for it. If a user has tweeted at two (or more) different times in our dataset it will be present the from its first tweet to its second tweet (+ 6 hours).

## Visualise

To tackle the visualisation let's bring back our rescaling function. As a reminder this is so that the nodes do not take `r max(tweets$created_at) - min(tweets$created_at)` to come and go but rather 60 seconds (60,000 milliseconds) as specified by the `t` argument.

```{r rescale ephemeral}
#' @param x Date time column.
#' @param t Number of milliseconds to rescale to.
rescale <- function(x, t){
  x <- as.numeric(x)
  x <-  (x - min(x)) / (max(x) - min(x))
  x <- x * t
  return(x)
}
```

Then onto preparing the data. We do something similar as we did previously expect we also rescale `end`. There was no need to do that before as there was no need to do that since nodes and edges were only appearing on the graph and not disappearing.

We add `500` milliseconds (half a second) to the edge created time to ensure that it is created after the node as we need the edges to be created based on nodes already drawn on the graph: an additional `200` milliseconds ensures the nodes each respective edge connects are present on the graph.

```{r, prepare ephemeral}
library(dplyr)

SCALE <- 60000 # 60 seconds

nodes <- nodes %>%
  nodes2sg() %>% 
  ungroup() %>% 
  mutate(
    start = rescale(start, SCALE),
    end = rescale(end, SCALE)
  ) %>%
  select(id, label, size, start, end)

edges <- edges %>%
  mutate(
    id = 1:n(),
    created_at = rescale(created_at, SCALE) + 200,
    end = rescale(end, SCALE) + (60 * 60 * 6)
  ) %>%
  select(id, source, target, start = created_at, end)
```

Finally onto the visualisation, we again use `sg_drop_nodes` and `sg_drop_edges`, but this time, as we want them to also disappear we also use `sg_drop_nodes` and `sg_drop_edges`. With regard to the latter functions, since we only need to remove them from the graph we just need to specify their respective ids.

Then again, we can specify the `x` and `y` coordinates as well as the color of the nodes whcih we'll base on clusters in order to make the graph look better.

```{r, beautify ephemeral}
nodes <- sg_get_layout(nodes, edges)

nodes <- sg_get_cluster(
  nodes, 
  edges,
  colors = c(
    "#0084b4",
    "#00aced",
    "#1dcaff",
    "#c0deed"
    )
  )
```

```{r, graph ephemeral}
sigmajs() %>% 
  sg_add_nodes(nodes, start, id, label, size, color, x, y, cumsum = FALSE) %>% 
  sg_add_edges(edges, start, id, source, target, cumsum = FALSE) %>% 
  sg_drop_nodes(nodes, id, end, cumsum = FALSE) %>% 
  sg_drop_edges(edges, id, end, cumsum = FALSE)
```

The animation is triggered on page launch, *reload the page if you missed it*. There is quite a bit going on in this visualisation; perhaps we should round the time at which nodes and edges are created to the hour.

Let's go ahead and do this.

```{r}
net <- tweets %>% 
  mutate(
    created_at = as.POSIXct(round(created_at, units = "hours"))
  ) %>% 
  gt_edges(text, screen_name, status_id, created_at = "created_at") %>% 
  gt_nodes() %>% 
  gt_dyn(60 * 60 * 6) %>% 
  gt_collect()

c(edges, nodes) %<-% net

nodes <- nodes %>%
  nodes2sg() %>% 
  ungroup() %>% 
  mutate(
    start = rescale(start, SCALE),
    end = rescale(end, SCALE)
  ) %>%
  select(id, label, size, start, end)

edges <- edges %>%
  mutate(
    id = 1:n(),
    created_at = rescale(created_at, SCALE) + 200,
    end = rescale(end, SCALE) + (60 * 60 * 6)
  ) %>%
  select(id, source, target, start = created_at, end)

nodes <- sg_get_layout(nodes, edges)

nodes <- sg_get_cluster(
  nodes, 
  edges,
  colors = c(
    "#0084b4",
    "#00aced",
    "#1dcaff",
    "#c0deed"
    )
  )

sigmajs() %>% 
  sg_add_nodes(nodes, start, id, label, size, color, x, y, cumsum = FALSE, refresh = FALSE) %>% 
  sg_add_edges(edges, start, id, source, target, cumsum = FALSE) %>% 
  sg_drop_nodes(nodes, id, end, cumsum = FALSE) %>% 
  sg_drop_edges(edges, id, end, cumsum = FALSE, refresh = FALSE) %>% 
  sg_button(
    "Launch",
    c(
      "add_nodes",
      "add_edges",
      "drop_nodes",
      "drop_edges"
    )
  )
```
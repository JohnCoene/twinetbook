# Hashtags {#hashtags}

```{r, echo=FALSE, include=FALSE}
library(twinetverse)

TK <- readRDS("twitter_token.rds")
```

The _twinetverse_, or graphTweets more specifically, not only enables visualising interactions between users, it also lets one build and visualise networks of users and the hashtag(s) they use.

Let's collect some tweets, since we want to plot relationships between users and hashtags we'll specify two hashtags: #python and #rstats. This way we'll be able to see who uses both or either. We'll also narrow it down to tweets in English to avoid #hashtags we cannot understand.

```{r hash search, eval=TRUE}
# TK <- readRDS(file = "token.rds")
tweets <- search_tweets("#rstats OR #python", n = 1000, token = TK, include_rts = FALSE, lang = "en")
```

Now let's build a network of hashtags to visualise which user tweets which #hashtag.

```{block, type = "tip"}
Use `gt_edges_hash` to build networks of users and hastags.
```

```{r hash net}
net <- tweets %>% 
  gt_edges_hash(hashtags, screen_name) %>% 
  gt_nodes() %>% 
  gt_collect()
```

Let's inspect the edges first.

```{r hash inpsect edges, eval = FALSE}
head(net$edges)
```

```{r, eval = TRUE, echo = FALSE}
knitr::kable(head(net$edges))
```

The edges include the `n_tweets` variable which is the number tweets the #hashtag is found in. Note that in order to ensure we can always distinguish between a user and a hashtag, hashtag are preceded by the the `#` sign. Let's take a look at the nodes.

```{r hash inspect nodes, eval = FALSE}
head(net$nodes)
```

```{r, eval = TRUE, echo = FALSE}
knitr::kable(head(net$nodes))
```

Nodes also include the `type` which is either set to `user` or `hashtag`.

Only one function changes, we use `gt_edges_hash` instead of `gt_edges`. While the latter builds networks of users, as we should be somewhat familiar with already, the former build networks that map users to the hashtags they use in their tweets, it thus make sense to pass `hashtags` instead of `text` as rtweet neatly extracts that for us.

Now onto the visualisation. As we did before, we unpack our network, then we prepare the data to fit sigmajs' expectation, and we color the nodes according to the `type`, one colour for #hashtags and another for \@users.

```{r hash unpack}
c(edges, nodes) %<-% net

nodes <- nodes2sg(nodes)
edges <- edges2sg(edges)

nodes$color <- ifelse(nodes$type == "user", "#0084b4", "#1dcaff")
```

In the visualisation we add `sg_neighbours` to *highlight* neighbours of the node clicked, try it.

```{r hash viz}
sigmajs() %>% 
  sg_nodes(nodes, id, size, color, label) %>% 
  sg_edges(edges, id, source, target) %>% 
  sg_layout(layout = igraph::layout_components) %>% 
  sg_settings(
    edgeColor = "default",
    defaultEdgeColor = "#d3d3d3"
  ) %>% 
  sg_neighbours()
```

It is interesting to see that few users actually tweet both hashtags, this _wouldn't_ have to be in the same tweet so it is somewhat surprising.

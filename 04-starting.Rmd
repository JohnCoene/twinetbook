# Get Started {#get-started}

```{r setup, echo=FALSE, include=FALSE}
library(dplyr)
library(twinetverse)

TK <- readRDS("twitter_token.rds")
```

In this chapter we briefly explore the twinetverse: we _collect_ tweets, _build_ and _visualise_ our first graph. 

## Collect

See the [prerequisites](#prerequisites) section if the line below confuses you.

```{r, eval=FALSE}
TK <- readRDS("token.rds")
```

rtweet lets you do a lot of things, however within the context of the _twinetverse_ we mainly use its `search_tweets` to get tweets.

```{r collect, eval=TRUE}
tweets <- search_tweets("rstats", token = TK)
```

The `search_tweets` function takes a few arguments which we'll eventually get into, above we run the simplest possible call; calling for tweets about "rstats", a reference to the R [@R-base] Twitter [#hashtag](https://twitter.com/search?q=rstats), by default the function returns 100 tweets. Note that we also pass our token to the function.

## Build

Now we can use the second package part of the _twinetverse_, graphTweets. Again, we'll leave function's arguments to default to get a simple graph. There's a lot more to the package which we'll explore in later chapters.

```{r, eval=TRUE}
net <- tweets %>% 
  gt_edges(text, screen_name, status_id)
```

We called `gt_edges` on our `tweets` data.frame, passing a few bare column names. The source of the tweets will also be the source of our edges so we pass `screen_name`, then the target of these edges will be users tagged in the tweets, `text` variable in rtweet. 

The object returned is of an unfamiliar class.

```{r, eval=TRUE}
class(net)
```

To extracts the results from graphTweets run `gt_collect`, this will work at any point in the chain of pipes (`%>%`).

```{r, eval=TRUE}
net <- net %>% 
  gt_collect()

class(net)
```

Great but this returns a lists and R users much prefer data.frames. graphTweets actualy returns two data.frames that encapsulated in a list. Indeed networks cannot be compressed into a single data.frame, we have 1) nodes and 2) edges.

```{r, eval=TRUE}
names(net)
```

Great, so it looks like we have both nodes and edges, not really. We only have edges, `net$nodes` is actually `NULL`. 

```{r, eval=TRUE}
lapply(net, class)
```

Well, we only ran `gt_edges` so it make sense that we only have edges. Let's scrap that and get both nodes and edges.

```{r, eval=TRUE}
net <- tweets %>% 
  gt_edges(text, screen_name, status_id) %>% # get edges
  gt_nodes() %>% # get nodes
  gt_collect() # collect

lapply(net, class)
```

Before we move on, something to note. graphTweets _requires_ that you run the functions in the correct order, first `gt_edges` and second `gt_nodes`. This is because one can only know the nodes of a graph based on the edges and not vice versa.

Now we're good, we have downloaded tweets and have everything we need to visualise it; nodes and edges.

## Visualise

We can visualise the network with sigmajs. Then again, it's very easy and follows the same idea as graphTweets; we pipe our nodes and edges through. Before we do so, for the sake of clarity, let's unpack our network using the `%<-%` from the Zeallot package [@R-zeallot], imported by the twinetverse.

```{r, eval=TRUE}
c(edges, nodes) %<-% net
```

Let's take a look at the edges.

```{r, eval=FALSE}
head(edges)
```

```{r, eval=TRUE, echo=FALSE}
knitr::kable(head(edges))
```

Edges simply consist of `source` and `target`, as explained earlier on, `source` essentially corresponds to `screen_name` passed in `gt_edges`, it is the user who posted the tweet. In contrast, `target` includes the users that were tagged in the `text` of the tweet.

Now let's take a look at the nodes:

```{r, eval=FALSE}
head(nodes)
```

```{r, eval=TRUE, echo=FALSE}
knitr::kable(head(nodes))
```

In the nodes data frame the column `n_edges` is the number edges the node appears in, while the `nodes` column are the Twitter handles of _both_ the authors of the tweets (`screen_name`) and those who were tagged in the tweets (`text`). 

Below we rename a few columns, to meet sigmajs' naming convention.

1. We add ids to our nodes, this can be a string and thus simply corresponds to our `nodes` column.
2. We essentially rename `n_edges` to `size` as this is what sigmajs understands (more on this later).
3. We add ids to our edges as sigmajs requires each edge to have a unique id.

```{r, eval = FALSE}
nodes$id <- as.factor(nodes$nodes) 
nodes$size <- nodes$n_edges 

edges$id <- seq(1, nrow(edges)) 
```

sigmajs has a specific but sensible naming convention as well as basic _minimal requirements_. 

* Nodes must at least include `id`, and `size`.
* Edges must at least include `id`, `source`, and `target`.

Actually, the twinetverse comes with helper functions to prepare the nodes and edges build from graphTweets for use in sigmajs.

```{r}
nodes <- nodes2sg(nodes)
edges <- edges2sg(edges)
```

Let's visualise that, we must initialise every sigmajs graph with the `sigmajs` function, then we add our nodes with `sg_nodes`, passing the column names we mentioned previously, `id`, and `size` to meet sigmajs' minimum requirements. *At the exception of `sigmajs`, all functions of the sigmajs package start with `sg_`*  

```{r, eval=TRUE}
sigmajs() %>% 
  sg_nodes(nodes, id, size) 
```

sigmajs actually allows you to build graphs using only nodes or edges, we'll see why this is useful in a later chapter on [temporal graphs](#dynamic). Let's add the edges. Then again, to meet sigmajs' requirements, we pass `id`, `source` and `target`.

```{r, eval=TRUE}
sigmajs() %>% 
  sg_nodes(nodes, id, size) %>% 
  sg_edges(edges, id, source, target)
```

This graph does not look great. We'll beautify that bit by bit as we move through the book: sigmajs is highly customisable. 

Nevermind beauty, what's on the graph exactly? Each disk/point on the graph is a twitter user, they are connected when one has tagged the other in the a tweet.

You may also notice that the graph contains surprisingly few nodes, given that we queried 100 tweets you would expect over 100 nodes on the graph. This is because our visualisation only includes tweets that mention other users and most tweets are not targeted (tagged) at other users. There is an easy remedy to this which we'll look at in the [advanced](advanced) chapter.

## Recap

This chapter aimed at demonstrating the basic principles behind the packages and the order in which to use the packages that form the _twinetverse_. The chapter may look long~ish but the code is not, here it is put together.

```{r, eval=FALSE}
library(dplyr)

# COLLECT
tweets <- search_tweets("rstats", token = TK)

# BUILD
net <- tweets %>% 
  gt_edges(text, screen_name, status_id) %>% 
  gt_nodes() %>% 
  gt_collect() 

c(edges, nodes) %<-% net

nodes <- nodes2sg(nodes)
edges <- edges2sg(edges)

# Visualise
sigmajs() %>% 
  sg_nodes(nodes, id, size) %>% 
  sg_edges(edges, id, source, target)
```

Remember the workflow of the _twinetverse_:

1. We **collect** the data
2. We **build** the graph
3. We **visualise** the network

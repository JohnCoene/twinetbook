# Advanced {#advanced}

```{r, echo=FALSE, include=FALSE}
library(twinetverse)

TK <- readRDS("twitter_token.rds")
```

In this chapter we essentially replicate what we did in the Get Started [chapter](get-started) but in a somewhat more advanced manner as we introduce new functions and arguments.

## Collect

Let's collect more tweets this time, we'll also optimise our Twitter query. This is very useful as the Twitter API (like the vast majority of APIs) limits the amount of data you can access by imposing a [rate limit](https://developer.twitter.com/en/docs/basics/rate-limiting.html).

We set `include_rts = FALSE` as we don't need the same tweet multiple times, it does not add information to our graph (currently but it could). We also pass a slightly more sophisticated query to the search tweet endpoint. This is too often overlooked, the Twitter API provides [advanced operators](https://developer.twitter.com/en/docs/tweets/search/guides/standard-operators.html): you are not limited to searching a single keyword every time.

We query 1,000 tweets that:

- Include `#rstats`
- Include a [mention](https://help.twitter.com/en/using-twitter/mentions-and-replies) i.e.: `@jdatap`
- Are original (not re-tweets)

Remember to load your token if you're in a new environment.

```{r, eval=TRUE}
# TK <- readRDS(file = "token.rds")
tweets <- search_tweets("#rstats filter:mentions", n = 1000, token = TK, include_rts = FALSE)
```

## Build

Let's build the graph, just like we did before. There is more to graphTweets but we won't look into that just yet.

```{r, eval=TRUE}
net <- tweets %>% 
  gt_edges(text, screen_name, status_id) %>% 
  gt_nodes() %>% 
  gt_collect()
```

## Visualise

Let's make a slightly more interesting visualisation this time. First, we'll prepare the data for sigmajs like we did in the [get started](#get-started) chapter.

```{r, eval=TRUE}
library(dplyr)

nodes <- net$nodes
edges <- net$edges

nodes <- nodes %>% 
  arrange(n_edges) %>% 
  mutate(
    id = nodes,
    label = nodes,
    size = n_edges
  )

edges$id <- seq(1, nrow(edges))
```

Now onto the visualisation.

* We add labels that will display on hover.
* We color the nodes by cluster.
* We layout the graph appropriately using one of igraph's [@R-igraph] many layout algorithms.
* We use sigmajs' settings to change the edges color.

```{r, eval=TRUE}
# Visualise
sigmajs("webgl") %>% 
  sg_nodes(nodes, id, label, size) %>% 
  sg_edges(edges, id, source, target) %>% 
  sg_layout() %>% 
  sg_cluster(
    colors = c(
      "#0084b4",
      "#00aced",
      "#1dcaff",
      "#c0deed"
      )
  ) %>% 
  sg_settings(
    minNodeSize = 1,
    maxNodeSize = 2.5,
    edgeColor = "default",
    defaultEdgeColor = "#d3d3d3"
  )
```

Already looking better.
[
["index.html", "The twinetverse Chapter 1 Prerequisites", " The twinetverse Visualise Networks of Twitter Interactions John Coene 2018-07-04 Chapter 1 Prerequisites The goal of the twinetverse is to provide everything one might need efficiently and elegantly visualise Twitter interactions. The twinetverse package can be installed from Github: devtools::install_github(&quot;JohnCoene/twinetverse&quot;) The package is unlikely to make it onto CRAN, it may be considered once all of its children packages are on CRAN, but not until then. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction The twinetverse includes three packages: rtweet graphTweets sigmajs Within the context of visualising Twitter interactions, each of the packages listed above fill in a specific need and a distinct step of the process, 1) collecting the data, 2) building the graphs and finally 3) visualising the graphs of said interactions. We eventually look at the packages that make up the twinetverse. "],
["pkgs.html", "Chapter 3 Packages 3.1 rtweet 3.2 graphTweets 3.3 sigmajs", " Chapter 3 Packages Below are the packages thatmake up in the twinetverse as well as some explanation of what they bring to visualising Twitter interactions. 3.1 rtweet If we are going to visualise Twitter interactions we are going to need data, namely tweets. The rtweet (Kearney 2018) package wraps the Twitter API, thereby giving R users easy access to tweets. The rtweet package requires some set up. This is not only extremely easy but also very well explained on rtweet’s official website, so head over there if the short description below does not satisfy. In essence, you will need a Twitter “app” to access its API (via rtweet), to create one: Head over to apps.twitter.com and login or signup if you do not have a Twitter account. Click create an app. In the following form, enter an app name, whatever you want, this does not matter. Enter a description, then again, it doesn’t matter. Website, simply put a valid website, you can link to your Twitter profile if you do not have one, i.e.: https://twitter.com/jdatap Callback URL, this is important, in there put the following: http://127.0.0.1:1410. You’re now setup, take note of the following under “Keys abd Access Tokens”, as you will need it to create your token and fetch tweets: Consumer Key (API Key) Consumer Secret (API Secret) Access Token Access Token Secret rtweet fills the very first step in visualising Twitter interactions, collecting the necessary data. Note that the package lets you do much more than simply downloading tweets, however, this is its main function within the twinetverse. 3.2 graphTweets The graphTweets (Coene 2018a) package lets you build lists of nodes and edges from tweets collected with rtweet. The package is faily straighforward and inludes but a few functions. However, it still enables you to extract construct dynamic graphs. All functions of the package start with gt_. graphTweets fills the seecond step in visualising Twitter interactions, building the graphs from the collected data. 3.3 sigmajs sigmajs (Coene 2018b) is a powerful library to visualise the networks we have built using graphTweets. The package, like graphTweets, is pipe-friendly (%&gt;%), therefore making it easy to go from building a graph to visualising it. It can also easily represent dynamic networks, something otherwise not evident in R. Features: Highly interactive Crosstalk integrated Includes Shiny proxies Events in Shiny Buttons to trigger interactions. and more. All functions of the package start with sg_. sigmajs is the final piece of the puzzle, visualising the graphs we have built. References "],
["get-started.html", "Chapter 4 Get Started 4.1 Collect 4.2 Build 4.3 Visualise 4.4 Recap", " Chapter 4 Get Started Here we just briefly explore each package and, together with the twinetverse. As expected the first thing to do is to collect the necessary data using rtweet, see the packages section to get setup to set this up. 4.1 Collect Let’s create a token. library(twinetverse) TK &lt;- create_token( &quot;My Application Name&quot;, consumer_key = &quot;XxxxXxXXxXx&quot;, consumer_secret = &quot;XxxxXxXXxXx&quot;, access_token = &quot;XxxxXxXXxXx&quot;, access_secret = &quot;XxxxXxXXxXx&quot; ) Now that you have a token you are ready to download get Twitter data. Before we do so let’s save our token; we’re going to use it quite a lot and there is no need to create a new one every time. saveRDS(TK, file = &quot;token.rds&quot;) You can always load your token with: TK &lt;- readRDS(&quot;token.rds&quot;) rtweet lets you do a lot of things, however within the context of the twinetverse we mainly use search_tweets to get tweets. tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) ## Searching for tweets... ## Finished collecting tweets! The search_tweets function takes a few arguments which we’ll eventually get into, above we run the simplest possible call; calling for tweets about “rstats”, a reference to the R (R Core Team 2017) Twitter #hashtag, by default the function returns 100 tweets. Note that we also pass our token to the function. 4.2 Build Now we can use the second package part of the twinetverse, graphTweets. Again, we’ll run a vary basic call to get a basic graph. There’s a lot more to the package which we’ll get into later. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) What did we just do? We simply call gt_edges on our tweets, specifying a few column names from our data.frame of tweets. The functions extracts the edges of the network; who is sending the tweet and who they tag in their the tweets. For instance, we now know that GoNorthStack tags gp_pulipaka in a tweet. Well, not really because the object returned is of an unfamiliar class. class(net) ## [1] &quot;graphTweets&quot; To extracts the results from graphTweets run gt_collect, this will work at any point in the chain of pipes (%&gt;%). net &lt;- net %&gt;% gt_collect() class(net) ## [1] &quot;list&quot; Ok great but this returns a list and we agreed in the methods section that data.frames are much clearer. Yes, but networks consist of two data.frames, one for edges and another for nodes. names(net) ## [1] &quot;edges&quot; &quot;nodes&quot; Great, we have both nodes and edges, not really. We only have edges, net$nodes is actually NULL. lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;NULL&quot; Well, we only ran gt_edges so it make sense that we only have edges. Let’s scrap that and get both nodes and edges. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% # get edges gt_nodes() %&gt;% # get nodes gt_collect() # collect lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Before we move on, something to note. graphTweets requires that you run the functions in the correct order, first gt_edges and second gt_nodes. This is because one can only know the nodes of a graph based on the edges. Now we’re good, we have downloaded tweets and have everything we need to visualise it; nodes and edges. 4.3 Visualise We can visualise the network with sigmajs. Then again, it’s very easy and follows the same idea as graphTweets; we pipe our nodes and edges through. Before we do so, let’s unpack our network for clarity’s sake, and inspect nodes and edges. nodes &lt;- net$nodes edges &lt;- net$edges head(edges); head(nodes) source target GoNorthStack gp_pulipaka GoNorthStack gp_pulipaka GoNorthStack gp_pulipaka JULIOMRS gp_pulipaka matteodefelice thomasp85 matteodefelice useR2018_conf nodes n_edges _Propulsion 1 _reactdev 1 AaronCuddeback 1 AdamGruer 1 AI_Nick_P 1 AlbertoGuzAlv 1 In the nodes data frame the column n_edges is the number edges the node appears in. Edges simplz returns source and target; source essentially corresponds to screen_name passed in gt_edges, it is the user who posted the tweet. In contrast, target includes the users that were tagged in the text of the tweet. Below we rename a few columns, to meet sigmajs’ naming convention. nodes$id &lt;- as.factor(nodes$nodes) # sigmajs requires a unique id (named id) nodes$size &lt;- nodes$n_edges # sigmajs requires node size named size edges$id &lt;- seq(1, nrow(edges)) # sigmajs requires a unique id (named id) sigmajs has a specific but sensible naming convention as well as basic minimal requirements. Nodes must at least include id, and size Edges must at least include id, source, and target. Let’s visualise that. sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) This graph does not look great. We’ll beautify that later on. Nevermind that, what’s on the graph exactly? Each disk on the graph is a twitter handle, they are connected when one has tagged the other in the a tweet. You may also notice that the graph contains surprisingly few nodes given that we queried 100 tweets. This is because our visualisation only includes tweets that mention other users and most tweets just do not. There is an easy remedy to this in the advanced chapter. 4.4 Recap This section aimed at demonstrating the basic of the package and order in which to use its components. The chapter may look long~ish but the code is not, here it is put together. library(dplyr) # COLLECT tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) # BUILD net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() nodes &lt;- net$nodes nodes$id &lt;- as.factor(nodes$nodes) nodes$size &lt;- nodes$n_edges edges &lt;- net$edges edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) We collect the data We build the graph We visualise the network References "],
["advanced.html", "Chapter 5 Advanced 5.1 Collect 5.2 Build 5.3 Visualise", " Chapter 5 Advanced In this chapter we essentially replicate what we did in the Get Started chapter but in a somewhat more advanced manner as we introduce a few new functions. 5.1 Collect Let’s collect more tweets this time, we’ll also set include_rts = FALSE as we dont’t need the same tweet multiple times, it does not add information. We also pass a slightly more sophisticated query to the search tweet endpoint, this is often overlooked, the Twitter API provides sophisticated operators, you are not limited to searching for a single keyword. We query tweets that: Include #rstats Include a mention i.e.: @jdatap Are not re-tweets Remember to load your token if you’re in a new environment. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 1000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 5.2 Build Let’s build the graph, just like we did before. There is more to graphTweets but we won’t look into that just yet. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() 5.3 Visualise Let’s make a slightly more interesting visualisation this time. We add labels (on hover). We add color (by node size). We layout the graph appropriately using igraph (file. 2018). We use settings to change the minimum and maximum node size as well as the edges color. library(dplyr) nodes &lt;- net$nodes edges &lt;- net$edges nodes &lt;- nodes %&gt;% arrange(n_edges) %&gt;% mutate( id = nodes, label = nodes, size = n_edges, color = colorRampPalette(c(&quot;#5fc1e8&quot;, &quot;#127ba3&quot;))(n()) ) edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs(&quot;webgl&quot;) %&gt;% sg_nodes(nodes, id, label, size, color) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_settings( edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Already looking better. References "],
["dynamic.html", "Chapter 6 Dynamic 6.1 Rationale 6.2 Collect 6.3 Build 6.4 Visualise", " Chapter 6 Dynamic So far we have been drawing static graphs, in this chapter we look at dynamic ones, namely temporal. 6.1 Rationale We’ve been visualising Twitter interactions in a static manner, but they are dynamic when you think of it, we’ve been drawing all encompassing snapshots. So let’s take into account the time factor; tweets are posted at specific time and should technically have specific life span (tweets do not “live” eternally&quot;). 6.2 Collect We’ll collect some tweets again, but feel free to use previously collected tweets; nothing changes at this stage. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 5000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 6.3 Build Now onto building the graph. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id, created_at = &quot;created_at&quot;) %&gt;% gt_nodes() %&gt;% gt_dyn() %&gt;% gt_collect() Quite a few things differ from previous graphs we have built. We pass created_at in gt_edges. This in effect adds the created_at column to our edges, so that we know the created time of post in which the edge appears. We use gt_dyn which stands for dynamic, which essentially computes the time at which edges and nodes should appear and disappear. lapply(net, head) ## $edges ## # A tibble: 6 x 4 ## source target created_at end ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;dttm&gt; ## 1 nj_clark ucfagls 2018-07-04 07:06:58 2018-07-04 07:06:58 ## 2 diwastha rstudio 2018-07-04 06:35:52 2018-07-04 07:06:58 ## 3 diwastha rstudio 2018-07-04 06:35:52 2018-07-04 07:06:58 ## 4 diwastha bjungbogati 2018-06-24 17:27:32 2018-07-04 07:06:58 ## 5 diwastha coursera 2018-06-24 17:27:32 2018-07-04 07:06:58 ## 6 diwastha MicrosoftR 2018-06-24 19:02:15 2018-07-04 07:06:58 ## ## $nodes ## # A tibble: 6 x 4 ## source start end n_edges ## &lt;chr&gt; &lt;dttm&gt; &lt;dttm&gt; &lt;int&gt; ## 1 &quot;&quot; 2018-06-24 17:13:43 2018-07-04 07:06:58 1 ## 2 @rstud 2018-07-02 11:16:27 2018-07-04 07:06:58 1 ## 3 __jsta&#39;s 2018-07-01 00:04:36 2018-07-04 07:06:58 1 ## 4 _abichat 2018-06-28 16:04:12 2018-07-04 07:06:58 1 ## 5 _bigjayy_ 2018-06-27 21:31:13 2018-07-04 07:06:58 1 ## 6 _ColinFay 2018-06-29 07:05:08 2018-07-04 07:06:58 1 Now for the visualisation, let’s build it step by step; first we prep the data as we did before, essentially renaming a few columns. However, we also run a few computations. To explain what we do we need to tackle how edges will be dinamically added to the graph. The this works in sigmajs is by specifying the delay in milliseconds before each respective edge should be added. Therefore, we need to transform the date to milliseconds and rescale them to be within a reasonable range (we don’t want the edges to actually take 15 days to appear on the graph). We change the date (POSIXct actually) to a numeric which gives the number of milliseconds since 1970. We rescale between 0 and 1 then multiply by 10,000 (milliseconds) so that the edges are added over 10 seconds. library(dplyr) library(zeallot) c(edges, nodes) %&lt;-% net # unpack nodes &lt;- nodes %&gt;% mutate( id = source, label = source, size = n_edges ) %&gt;% select(id, label, size) edges &lt;- edges %&gt;% mutate( id = 1:n(), created_at = as.numeric(created_at), created_at = (created_at - min(created_at)) / (max(created_at) - min(created_at)), created_at = created_at * 10000 ) %&gt;% select(id, source, target, created_at) We do the above because simgajs does not take date time as input but milliseconds. Now, the actual visualisation, as mentioned at the begining to the chapter, we’ll plot the nodes then add edges dynamically. Let’s break it down step by step. 6.4 Visualise First, we plot the nodes. sigmajs() %&gt;% sg_nodes(nodes, id, size, label) We’ll add the layout as it looks a bit messy as it is. We’ll have to compute the layout differently this time, we cannot simply use g_layout as it requries both nodes and edges and we only have nodes on the graph; instead we use sg_get_layout. This is something that we had not shared with you earlier on, sg_nodes ideally takes the x and y coordinates, if missing they are generated randomly. We simply compute those coordinates then bind them to our nodes. layout &lt;- sg_get_layout(nodes, edges) nodes &lt;- nodes %&gt;% bind_cols(layout) head(nodes) id label size x y 1 -24.115556 175.70188 (???) (???) 1 -133.667035 -85.95965 __jsta’s __jsta’s 1 53.068066 -64.18718 _abichat _abichat 1 2.607808 188.70243 bigjayy bigjayy 1 64.133229 25.93248 _ColinFay _ColinFay 1 -15.906230 -39.80706 Now we can simply pass the coordinates x and y to sg_nodes. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) Let’s beautify the graph a little, this deep black is somewhat unnerving. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Now we have something that looks like a graph, except it’s missing edges. Let’s add them. We add the edges almost exactly as we did before, we use sg_add_edges instead of sg_edges. Other than the function name, the only difference is that we pass created_at as delay. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Now the edges appear dynamically. However you probably missed that as the animation is triggered when the page is loaded. sigmajs provides an easy workaround: we can add a button for the user to trigger the animation themself. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_button(&quot;Add edges&quot;, &quot;add_edges&quot;) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) "],
["references.html", "References", " References "]
]

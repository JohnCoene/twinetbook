[
["index.html", "The twinetverse Chapter 1 Prerequisites", " The twinetverse John Coene 2018-07-03 Chapter 1 Prerequisites The goal of the twinetverse is to provide everything one might need efficiently and elegantly visualise Twitter interactions. The twinetverse package can be installed from Github: devtools::install_github(&quot;JohnCoene/twinetverse&quot;) The package is unlikely to make it onto CRAN, it may be considered once all of its children packges are on CRAN, but not until then. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction The twinetverse includes three packages: rtweet graphTweets sigmajs Within the context of visualising Twitter interactions, each of the packages listed above fill in a specific need and a distinct step of the process, 1) collecting the data, 2) building the graphs and finally 3) visualising the graphs. We eventually look at the packages that make up the twinetverse. "],
["methods.html", "Chapter 3 Methods 3.1 Tweets 3.2 Networks", " Chapter 3 Methods The core idea behind the twinetverse is fairly simply. Data is often put into rectangular format (think rows and columns, i.e.:data.frame) simply because it is most easily stored, and probably because we are familiar with the CSV table. As a result we tend to picture data in that format, including tweets. However, tweets, like other datasets, should perhaps not be thought of in such a manner. Forcing data into a continuous list-like rectangular format often narrows our perspective of the said dataset. Let’s illustrate with the case at hand, tweets. 3.1 Tweets Tweets appears in your timeline vertically, one after the other which make you can already picture the rowwise operation, each tweet is a row and each variable (author, text, created date, etc.), in fact this is how rtweet retruns tweets (more on that later). The table (data.frame) is a truly great invention, everyone gets is, even your dad (“yes, like Excel!”). However, I argue that it tends to restricts our vision of certain datasets, including tweets. Tables probably became popular, in part, because they not only structure data but also simplify it in some way. The simplification of the dataset subsequently simplifies their analysis. Tweets, shouldn’t be restricted to a table; it removes interesting and insightful complexity. Here is an example of tweet: ICYMI, 攼㹤愼㸰戼㹤攼㹤戼㸳㠼㹡 Easy viz from #rtweet data!攼㹤愼㸰戼㹤攼㹤戼㸰愼㸶 “GraphTweets: Visualise Twitter Interactions” ✩ (???)https://t.co/SCN0Ycy7Z7 #rstats #dataviz pic.twitter.com/9W4cNkEjf8 — Mara Averick ((???)) June 28, 2018 dataandme tweets jdatap. This should not be a single row of data isolated to my response to Mara’s tweet. These should be looked at as connected data points; what better way than a network. 3.2 Networks The beauty of networks is that they do not remove complexity and their implicit insights, they instead map it. Thereby making sense of the complexity and revealing insights. That is the aim of the twinetverse. By allowing the analyst a view tweets in a totally new fashion, twinetverse enables uncovering new insights that otherwise would not be apparent. "],
["pkgs.html", "Chapter 4 Packages 4.1 rtweet 4.2 graphTweets 4.3 sigmajs", " Chapter 4 Packages Below are the packages that are included in the twinetverse and what they bring to our endeavour of visualising Twitter interactions. 4.1 rtweet If we are going to visualise Twitter interactions we are going to need data, namely tweets. The rtweet package wraps the Twitter API, thereby giving R users easy access to tweets. The rtweet package requires some set up. This is not only extremely easy but also very well explained on rtweet’s official website, so head over there if the short description below does not satisfy. In essence, you will need a Twitter “app” to access its API (via rtweet), to create one: Head over to apps.twitter.com and login or signup if you do not have a Twitter account. Click create an app. In the following form, enter an app name, whatever you want, this does not matter. Enter a description, then again, it doesn’t matter. Website, simply put a valid website, you can link to your Twitter profile if you do not have one, i.e.: https://twitter.com/jdatap Callback URL, this is important, in there put the following: http://127.0.0.1:1410. You’re now setup, take note of the following under “Keys abd Access Tokens”, as you will need it to create your token and fetch tweets: Consumer Key (API Key) Consumer Secret (API Secret) Access Token Access Token Secret rtweet fills the very first step in visualising Twitter interactions, collecting the necessary data. Note that the package lets you do much more than simply downloading tweets, however, this is its main function within the twinetverse. 4.2 graphTweets The graphTweets package lets you build lists of nodes and edges from tweets collected with rtweet. The package is faily straighforward and inludes but a few functions. However it still enables you to extract valuable variables to build dynamic graphs. All functions of the package start with gt_. graphTweets fills the seecond step in visualising Twitter interactions, building the graphs from the collected data. 4.3 sigmajs sigmajs is a powerful library to visualise the networks we have built using graphTweets. The package, like graphTweets, is pipe-friendly (%&gt;%), therefore making it easy to go from building a graph to visualising it. It can also easily let you visualise dynamic networks, which is otherwise not evident in R. Features: Highly interactive Crosstalk integrated Includes Shiny proxies Events in Shiny Buttons to trigger interactions. and more. All functions of the package start with sg_. sigmajs is the final piece of the puzzle, visualising the graphs we have built. "],
["get-started.html", "Chapter 5 Get Started 5.1 Get tweets 5.2 Build graph 5.3 Visualise 5.4 Recap", " Chapter 5 Get Started Here we just briefly explore each package and, together with the twinetverse. As expected the first thing to do is to collect the necessary data using rtweet, see the packages section to get setup to set this up. 5.1 Get tweets Let’s create a token. library(twinetverse) TK &lt;- create_token( &quot;My Application Name&quot;, consumer_key = &quot;XxxxXxXXxXx&quot;, consumer_secret = &quot;XxxxXxXXxXx&quot;, access_token = &quot;XxxxXxXXxXx&quot;, access_secret = &quot;XxxxXxXXxXx&quot; ) Now that you have a token you are ready to download get Twitter data. Before we do so let’s save our token; we’re going to use it quite a lot and there is no need to create a new one every time. saveRDS(TK, file = &quot;token.rds&quot;) You can also load your token with: TK &lt;- readRDS(file = &quot;token.rds&quot;) rtweet and the token you lets you do a lot of things, however within the context of the twinetverse we mainly use search_tweets to get tweets. tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) ## Searching for tweets... ## Finished collecting tweets! The search_tweets function takes a few arguments which we’ll eventually get into, above we run the simplest possible call; return tweets about “rstats”, a reference to the R (R Core Team 2017) Twitter #hashtag, by default the function returns 100 tweets (n = 100). Note that we also pass our token. 5.2 Build graph Now we can use the second package part of the twinetverse, graphTweets. Again, we’ll run a vary basic call to get a basic graph. There’s a lot more to the package but we’ll get into that later. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) What did we just do? We simply call gt_edges on our tweets, specifying a few column names from our data.frame of tweets. The functions extracts the edges of the network; who is tagging who in the tweets. For instance, we now know that mdsumner tags nj_tierney in a tweet. Well, not really because the object returned is of an unfamiliar class. class(net) ## [1] &quot;graphTweets&quot; To extracts the results from graphTweets run gt_collect, this will work at any point in the chain of pipes (%&gt;%). net &lt;- net %&gt;% gt_collect() class(net) ## [1] &quot;list&quot; Ok great but this returns a list and we agreed in the methods section that data.frames are much clearer. Yes, but networks consist of two data.frames, one for edges and another for nodes. names(net) ## [1] &quot;edges&quot; &quot;nodes&quot; Great, we have both nodes and edges, not really. We only have edges, net$nodes is actually NULL. lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;NULL&quot; Well, we only ran gt_edges so it make sense that we only have edges. Let’s scrap that and get both nodes and edges. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% # get edges gt_nodes() %&gt;% # get nodes gt_collect() # collect lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Before we move on, something to note. graphTweets requires that you run the functions in the correct order, first gt_edges and second gt_nodes. This is because one can only know the nodes of a graph based on the edges. Now we’re good, we have downloaded tweets and have everything we need to visualise it; nodes and edges. 5.3 Visualise We can visualise the network with sigmajs. Then again, it’s very easy and follows the same idea as graphTweets; we pipe our nodes and edges through. Before we do so, let’s unpack our network for clarity’s sake, and rename some columns to conform with sigmajs’ convention. # unpack nodes nodes &lt;- net$nodes nodes$id &lt;- as.factor(nodes$nodes) # sigmajs requires a unique id (named id) nodes$size &lt;- nodes$n_edges # sigmajs requires node size named size # unpack edges edges &lt;- net$edges edges$id &lt;- seq(1, nrow(edges)) # sigmajs requires a unique id (named id) sigmajs has a specific but sensible naming convention as well as basic minimal requirements. Nodes must at least include id, and size Edges must at least include id, source, and target. Let’s visualise that. sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) &lt;!iv id=\"htmlwidget-461177632624c9f13d8f\" class=\"sigmajs html-widget\" style=\"width:100%;height:480px;\"> advanced chapter. 5.4 Recap This section aimed at demonstrating the basic of the package and order in which to use its components. The chapter may look long~ish but the code is not, here it is put together. library(dplyr) # COLLECT tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) # BUILD net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() nodes &lt;- net$nodes nodes$id &lt;- as.factor(nodes$nodes) nodes$size &lt;- nodes$n_edges edges &lt;- net$edges edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) We collect the data We build the graph We visualise the network References "],
["advanced.html", "Chapter 6 Advanced 6.1 Collect 6.2 Build 6.3 Visualise", " Chapter 6 Advanced In this chapter we essentially replicate what we did in the Get Started chapter but in a somewhat more advanced manner as we introduce a few new functions. 6.1 Collect Let’s collect more tweets this time, we’ll also set include_rts = FALSE as we dont’t need the same tweet multiple times, it does not add information. We also pass a slightly more sophisticated query to the search tweet endpoint, this is often overlooked, the Twitter API provides sophisticated operators, you are not limited to search for a single keyword. Query tweets that: Include #rstats Include a mention i.e.: @jdatap Are not re-tweets Remember to load your token if you’re in a new environment. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 1000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 6.2 Build Let’s build the graph, just like we did before. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() 6.3 Visualise Let’s make a slightly more interesting visualisation this time. We add labels (on hover). We add color (by node size). We layout the graph appropriately. We use settings to change the minimum and maximum node size as well as the edges color. library(dplyr) nodes &lt;- net$nodes edges &lt;- net$edges nodes &lt;- nodes %&gt;% arrange(n_edges) %&gt;% mutate( id = nodes, label = nodes, size = n_edges, color = colorRampPalette(c(&quot;#5fc1e8&quot;, &quot;#127ba3&quot;))(n()) ) edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs(&quot;webgl&quot;) %&gt;% sg_nodes(nodes, id, label, size, color) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_settings( edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) &lt;!iv id=\"htmlwidget-2b58f08d7d47e135bd8f\" class=\"sigmajs html-widget\" style=\"width:100%;height:480px;\"> "],
["references.html", "References", " References "]
]

[
["index.html", "The twinetverse Chapter 1 Prerequisites", " The twinetverse John Coene 2018-07-03 Chapter 1 Prerequisites The goal of the twinetverse is to provide everything one might need efficiently and elegantly visualise Twitter interactions. The twinetverse package can be installed from Github: devtools::install_github(&quot;JohnCoene/twinetverse&quot;) The package is unlikely to make it onto CRAN, it may be considered once all of its children packages are on CRAN, but not until then. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction The twinetverse includes three packages: rtweet graphTweets sigmajs Within the context of visualising Twitter interactions, each of the packages listed above fill in a specific need and a distinct step of the process, 1) collecting the data, 2) building the graphs and finally 3) visualising the graphs of said interactions. We eventually look at the packages that make up the twinetverse. "],
["pkgs.html", "Chapter 3 Packages 3.1 rtweet 3.2 graphTweets 3.3 sigmajs", " Chapter 3 Packages Below are the packages thatmake up in the twinetverse as well as some explanation of what they bring to visualising Twitter interactions. 3.1 rtweet If we are going to visualise Twitter interactions we are going to need data, namely tweets. The rtweet (Kearney 2018) package wraps the Twitter API, thereby giving R users easy access to tweets. The rtweet package requires some set up. This is not only extremely easy but also very well explained on rtweet’s official website, so head over there if the short description below does not satisfy. In essence, you will need a Twitter “app” to access its API (via rtweet), to create one: Head over to apps.twitter.com and login or signup if you do not have a Twitter account. Click create an app. In the following form, enter an app name, whatever you want, this does not matter. Enter a description, then again, it doesn’t matter. Website, simply put a valid website, you can link to your Twitter profile if you do not have one, i.e.: https://twitter.com/jdatap Callback URL, this is important, in there put the following: http://127.0.0.1:1410. You’re now setup, take note of the following under “Keys abd Access Tokens”, as you will need it to create your token and fetch tweets: Consumer Key (API Key) Consumer Secret (API Secret) Access Token Access Token Secret rtweet fills the very first step in visualising Twitter interactions, collecting the necessary data. Note that the package lets you do much more than simply downloading tweets, however, this is its main function within the twinetverse. 3.2 graphTweets The graphTweets (Coene 2018a) package lets you build lists of nodes and edges from tweets collected with rtweet. The package is faily straighforward and inludes but a few functions. However, it still enables you to extract construct dynamic graphs. All functions of the package start with gt_. graphTweets fills the seecond step in visualising Twitter interactions, building the graphs from the collected data. 3.3 sigmajs sigmajs (Coene 2018b) is a powerful library to visualise the networks we have built using graphTweets. The package, like graphTweets, is pipe-friendly (%&gt;%), therefore making it easy to go from building a graph to visualising it. It can also easily represent dynamic networks, something otherwise not evident in R. Features: Highly interactive Crosstalk integrated Includes Shiny proxies Events in Shiny Buttons to trigger interactions. and more. All functions of the package start with sg_. sigmajs is the final piece of the puzzle, visualising the graphs we have built. References "],
["get-started.html", "Chapter 4 Get Started 4.1 Get tweets 4.2 Build graph 4.3 Visualise 4.4 Recap", " Chapter 4 Get Started Here we just briefly explore each package and, together with the twinetverse. As expected the first thing to do is to collect the necessary data using rtweet, see the packages section to get setup to set this up. 4.1 Get tweets Let’s create a token. library(twinetverse) TK &lt;- create_token( &quot;My Application Name&quot;, consumer_key = &quot;XxxxXxXXxXx&quot;, consumer_secret = &quot;XxxxXxXXxXx&quot;, access_token = &quot;XxxxXxXXxXx&quot;, access_secret = &quot;XxxxXxXXxXx&quot; ) Now that you have a token you are ready to download get Twitter data. Before we do so let’s save our token; we’re going to use it quite a lot and there is no need to create a new one every time. saveRDS(TK, file = &quot;token.rds&quot;) You can always load your token with: TK &lt;- readRDS(&quot;token.rds&quot;) rtweet lets you do a lot of things, however within the context of the twinetverse we mainly use search_tweets to get tweets. tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) ## Searching for tweets... ## Finished collecting tweets! The search_tweets function takes a few arguments which we’ll eventually get into, above we run the simplest possible call; calling for tweets about “rstats”, a reference to the R (R Core Team 2017) Twitter #hashtag, by default the function returns 100 tweets. Note that we also pass our token to the function. 4.2 Build graph Now we can use the second package part of the twinetverse, graphTweets. Again, we’ll run a vary basic call to get a basic graph. There’s a lot more to the package which we’ll get into later. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) What did we just do? We simply call gt_edges on our tweets, specifying a few column names from our data.frame of tweets. The functions extracts the edges of the network; who is sending the tweet and who they tag in their the tweets. For instance, we now know that WalkingImpress tags Ceo_Branding in a tweet. Well, not really because the object returned is of an unfamiliar class. class(net) ## [1] &quot;graphTweets&quot; To extracts the results from graphTweets run gt_collect, this will work at any point in the chain of pipes (%&gt;%). net &lt;- net %&gt;% gt_collect() class(net) ## [1] &quot;list&quot; Ok great but this returns a list and we agreed in the methods section that data.frames are much clearer. Yes, but networks consist of two data.frames, one for edges and another for nodes. names(net) ## [1] &quot;edges&quot; &quot;nodes&quot; Great, we have both nodes and edges, not really. We only have edges, net$nodes is actually NULL. lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;NULL&quot; Well, we only ran gt_edges so it make sense that we only have edges. Let’s scrap that and get both nodes and edges. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% # get edges gt_nodes() %&gt;% # get nodes gt_collect() # collect lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Before we move on, something to note. graphTweets requires that you run the functions in the correct order, first gt_edges and second gt_nodes. This is because one can only know the nodes of a graph based on the edges. Now we’re good, we have downloaded tweets and have everything we need to visualise it; nodes and edges. 4.3 Visualise We can visualise the network with sigmajs. Then again, it’s very easy and follows the same idea as graphTweets; we pipe our nodes and edges through. Before we do so, let’s unpack our network for clarity’s sake, and inspect nodes and edges. nodes &lt;- net$nodes edges &lt;- net$edges head(edges); head(nodes) source target WalkingImpress Ceo_Branding WalkingImpress MikeQuindazzi WalkingImpress ipfconline1 whyRconf kovacbranko whyRconf whyRconf whyRconf KateKatePaul nodes n_edges _reactdev 1 _SevillaR 1 520507 2 Aarleks 1 abarrio75 1 AdamGruer 1 In the nodes data frame the column n_edges is the number edges the node appears in. Edges simplz returns source and target; source essentially corresponds to screen_name passed in gt_edges, it is the user who posted the tweet. In contrast, target includes the users that were tagged in the text of the tweet. Below we rename a few columns, to meet sigmajs’ naming convention. nodes$id &lt;- as.factor(nodes$nodes) # sigmajs requires a unique id (named id) nodes$size &lt;- nodes$n_edges # sigmajs requires node size named size edges$id &lt;- seq(1, nrow(edges)) # sigmajs requires a unique id (named id) sigmajs has a specific but sensible naming convention as well as basic minimal requirements. Nodes must at least include id, and size Edges must at least include id, source, and target. Let’s visualise that. sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) This graph does not look great. We’ll beautify that later on. Nevermind that, what’s on the graph exactly? Each disk on the graph is a twitter handle, they are connected when one has tagged the other in the a tweet. You may also notice that the graph contains surprisingly few nodes given that we queried 100 tweets. This is because our visualisation only includes tweets that mention other users and most tweets just do not. There is an easy remedy to this in the advanced chapter. 4.4 Recap This section aimed at demonstrating the basic of the package and order in which to use its components. The chapter may look long~ish but the code is not, here it is put together. library(dplyr) # COLLECT tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) # BUILD net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() nodes &lt;- net$nodes nodes$id &lt;- as.factor(nodes$nodes) nodes$size &lt;- nodes$n_edges edges &lt;- net$edges edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) We collect the data We build the graph We visualise the network References "],
["advanced.html", "Chapter 5 Advanced 5.1 Collect 5.2 Build 5.3 Visualise", " Chapter 5 Advanced In this chapter we essentially replicate what we did in the Get Started chapter but in a somewhat more advanced manner as we introduce a few new functions. 5.1 Collect Let’s collect more tweets this time, we’ll also set include_rts = FALSE as we dont’t need the same tweet multiple times, it does not add information. We also pass a slightly more sophisticated query to the search tweet endpoint, this is often overlooked, the Twitter API provides sophisticated operators, you are not limited to searching for a single keyword. We query tweets that: Include #rstats Include a mention i.e.: @jdatap Are not re-tweets Remember to load your token if you’re in a new environment. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 1000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 5.2 Build Let’s build the graph, just like we did before. There is more to graphTweets but we won’t look into that just yet. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() 5.3 Visualise Let’s make a slightly more interesting visualisation this time. We add labels (on hover). We add color (by node size). We layout the graph appropriately using igraph (file. 2018). We use settings to change the minimum and maximum node size as well as the edges color. library(dplyr) ## Warning: package &#39;dplyr&#39; was built under R version 3.4.4 ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union nodes &lt;- net$nodes edges &lt;- net$edges nodes &lt;- nodes %&gt;% arrange(n_edges) %&gt;% mutate( id = nodes, label = nodes, size = n_edges, color = colorRampPalette(c(&quot;#5fc1e8&quot;, &quot;#127ba3&quot;))(n()) ) edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs(&quot;webgl&quot;) %&gt;% sg_nodes(nodes, id, label, size, color) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_settings( edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Already looking better. References "],
["references.html", "References", " References "]
]

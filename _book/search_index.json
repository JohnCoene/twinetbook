[
["index.html", "The twinetverse Chapter 1 Preface", " The twinetverse Visualise Networks of Twitter Interactions John Coene 2018-07-06 Chapter 1 Preface The goal of the twinetverse is to provide everything one might need to view Twitter interactions, from data collection to visualisation. The twinetverse package can be installed from Github: devtools::install_github(&quot;JohnCoene/twinetverse&quot;) or from Bitbucket: devtools::install_bitbucket(&quot;JohnCoene/twinetverse&quot;) The package is unlikely to make it onto CRAN, it may be considered once all of its children packages are on CRAN, but not until then. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction The twinetverse includes three packages: rtweet graphTweets sigmajs Within the context of visualising Twitter interactions, each of the packages listed above fill in a specific need and a distinct step of the process, 1) collecting the data, 2) building the graphs and finally 3) visualising the graphs of said interactions. We eventually look at the packages that make up the twinetverse. "],
["pkgs.html", "Chapter 3 Packages 3.1 rtweet 3.2 graphTweets 3.3 sigmajs", " Chapter 3 Packages Below are the packages that make up in the twinetverse as well as some explanation of what they bring to visualising Twitter interactions. 3.1 rtweet If we are going to visualise Twitter interactions we are going to need data, namely tweets. The rtweet package (Kearney 2018) wraps the Twitter API, thereby giving R users easy access to tweets. 3.1.1 Usage rtweet fills the very first step in visualising Twitter interactions, collecting the necessary data. Note that the package lets you do much more than simply downloading tweets, however, this is its main function within the twinetverse. 3.2 graphTweets 3.2.1 Rationale The graphTweets package (Coene 2018a) lets you build lists of nodes and edges from tweets collected with rtweet. The package is faily straighforward and inludes but a few functions. However, it still enables you to build relatively complex graphs. The package revolves around two core functions which respectively allow you to build data.frames of edges and nodes. These edges and nodes (also referred to as vertices) together map Twitter conversations by linking the sender of a tweet to the user(s) he or she (???). 3.2.2 Usage All functions of the package start with gt_. graphTweets fills the seecond step in visualising Twitter interactions, building the graphs from the collected data. 3.3 sigmajs The sigmajs package (Coene 2018b) is a powerful library to visualise the networks we have built using graphTweets. The package, like graphTweets, is pipe-friendly (%&gt;%), therefore making it easy to go from building a graph to visualising it. It can also easily represent dynamic networks, something otherwise not evident in R. Features: Highly interactive Crosstalk integrated Includes Shiny proxies Events in Shiny Buttons to trigger interactions. and more. 3.3.1 Usage All functions of the package start with sg_. sigmajs is the final piece of the puzzle, visualising the graphs we have built. References "],
["prerequisites.html", "Chapter 4 Prerequisites 4.1 Install 4.2 Setup rtweet", " Chapter 4 Prerequisites In this chapter we get you set up and running with the twinetverse. 4.1 Install The twinetverse package can be installed from Github: devtools::install_github(&quot;JohnCoene/twinetverse&quot;) or from Bitbucket: devtools::install_bitbucket(&quot;JohnCoene/twinetverse&quot;) In the book we don’t explicitly load the package and assume you have loaded in your environment: library(twinetverse) 4.2 Setup rtweet The rtweet package requires some set up. This is not only extremely easy but also very well explained on rtweet’s official website, so head over there if the short description below does not satisfy. In essence, you will need a Twitter “app” to access its API, to create one: Head over to apps.twitter.com and login or signup if you do not have a Twitter account. Click create an app. In the following form, enter an app name, whatever you want, this does not matter. Enter a description, then again, it doesn’t matter. Website, simply put a valid website, you can link to your Twitter profile if you do not have one, i.e.: https://twitter.com/jdatap Callback URL, this is important, in there put the following: http://127.0.0.1:1410. You’re now setup with an app, take note of the following under “Keys and Access Tokens”, as you will need it to create your token and fetch tweets: Consumer Key (API Key) Consumer Secret (API Secret) Access Token Access Token Secret Create your token with like so. library(twinetverse) TK &lt;- create_token( &quot;My Application Name&quot;, consumer_key = &quot;XxxxXxXXxXx&quot;, consumer_secret = &quot;XxxxXxXXxXx&quot;, access_token = &quot;XxxxXxXXxXx&quot;, access_secret = &quot;XxxxXxXXxXx&quot; ) Ideally, also save it. There is no need to re-create a token everytime you want to download data. Once saved you can easily load it readRDS. saveRDS(TK, file = &quot;token.rds&quot;) You’re all set to use the twinetverse! "],
["get-started.html", "Chapter 5 Get Started 5.1 Collect 5.2 Build 5.3 Visualise 5.4 Recap", " Chapter 5 Get Started In this chapter we briefly explore the twinetverse: we collect tweets, build and visualise our first graph. 5.1 Collect See the prerequisites section if the line below confuses you. TK &lt;- readRDS(&quot;token.rds&quot;) rtweet lets you do a lot of things, however within the context of the twinetverse we mainly use search_tweets to get tweets. tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) ## Searching for tweets... ## Finished collecting tweets! The search_tweets function takes a few arguments which we’ll eventually get into, above we run the simplest possible call; calling for tweets about “rstats”, a reference to the R (R Core Team 2017) Twitter #hashtag, by default the function returns 100 tweets. Note that we also pass our token to the function. 5.2 Build Now we can use the second package part of the twinetverse, graphTweets. Again, we’ll function’s arguments to default to get a simple graph. There’s a lot more to the package which we’ll get into later. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) We called gt_edges on our tweets, specifying a few column names from our data.frame of tweets. The source of the tweets will also be the source of our edges so we pass screen_name, then the target of these edges will be users tagged in the tweets, text in rtweet. For instance, we now know that “mpane21” tags “bradleyboehmke” in a tweet. Well, not really because the object returned is of an unfamiliar class. class(net) ## [1] &quot;graphTweets&quot; To extracts the results from graphTweets run gt_collect, this will work at any point in the chain of pipes (%&gt;%). net &lt;- net %&gt;% gt_collect() class(net) ## [1] &quot;list&quot; Great but this returns a lists and R users much prefer data.frames. graphTweets actualy returns two data.frames that encapsulated in a list. Indeed networks cannot be compressed into a single data.frame, we have 1) nodes and 2) edges. names(net) ## [1] &quot;edges&quot; &quot;nodes&quot; Great, so it looks like we have both nodes and edges, not really. We only have edges, net$nodes is actually NULL. lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;NULL&quot; Well, we only ran gt_edges so it make sense that we only have edges. Let’s scrap that and get both nodes and edges. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% # get edges gt_nodes() %&gt;% # get nodes gt_collect() # collect lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Before we move on, something to note. graphTweets requires that you run the functions in the correct order, first gt_edges and second gt_nodes. This is because one can only know the nodes of a graph based on the edges and not vice versa. Now we’re good, we have downloaded tweets and have everything we need to visualise it; nodes and edges. 5.3 Visualise We can visualise the network with sigmajs. Then again, it’s very easy and follows the same idea as graphTweets; we pipe our nodes and edges through. Before we do so, let’s unpack our network for clarity’s sake. nodes &lt;- net$nodes edges &lt;- net$edges Let’s take a look at the edges. head(edges) source target mpane21 bradleyboehmke statsepi ma_salmon statsepi DavidGohel LeviLBall gp_pulipaka LeviLBall gp_pulipaka PHaltrup dwhitena Edges simply consist of source and target, as explained earlier on, source essentially corresponds to screen_name passed in gt_edges, it is the user who posted the tweet. In contrast, target includes the users that were tagged in the text of the tweet. Now let’s take a look at the nodes: head(nodes) nodes type n_edges _abichat user 16 _CitizenScience user 1 _ColinFay user 7 _SevillaR user 1 3wen user 5 abremges user 1 In the nodes data frame the column n_edges is the number edges the node appears in, while the nodes column are the Twitter handles of both the authors of the tweets (screen_name) and those who were tagged in the tweets (text). Below we rename a few columns, to meet sigmajs’ naming convention. We add ids to our nodes, this can be a string and thus simply corresponds to our nodes column. We essentially rename n_edges to size as this is what sigmajs understands (more on this later). We add ids to our edges as sigmajs requires each edge to have a unique id. nodes$id &lt;- as.factor(nodes$nodes) # sigmajs requires a unique id (named id) nodes$size &lt;- nodes$n_edges # sigmajs requires node size named size edges$id &lt;- seq(1, nrow(edges)) # sigmajs requires a unique id (named id) sigmajs has a specific but sensible naming convention as well as basic minimal requirements. Nodes must at least include id, and size. Edges must at least include id, source, and target. Let’s visualise that, we must initialise every sigmajs graph with the sigmajs function, then we add our nodes with sg_nodes, passing the column names we mentioned previously, id, and size to meet sigmajs’ minimum requirements. At the exception of sigmajs, all functions of the sigmajs package start with sg_ sigmajs() %&gt;% sg_nodes(nodes, id, size) sigmajs actually allows you to build graphs using only nodes or edges, we’ll see why this is useful in a later chapter on temporal graphs. Let’s add the edges. Then again, to meet sigmajs’ requirements, we pass id, source and target. sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) This graph does not look great. We’ll beautify that bit by bit as we move through the book: sigmajs is highly customisable. Nevermind beauty, what’s on the graph exactly? Each disk/point on the graph is a twitter user, they are connected when one has tagged the other in the a tweet. You may also notice that the graph contains surprisingly few nodes, given that we queried 100 tweets you would expect over 100 nodes on the graph. This is because our visualisation only includes tweets that mention other users and most tweets are not targeted (tagged) at other users. There is an easy remedy to this which we’ll look at in the advanced chapter. 5.4 Recap This chapter aimed at demonstrating the basic principles behind the packages and the order in which to use the packages that form the twinetverse. The chapter may look long~ish but the code is not, here it is put together. library(dplyr) # COLLECT tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) # BUILD net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() nodes &lt;- net$nodes nodes$id &lt;- as.factor(nodes$nodes) nodes$size &lt;- nodes$n_edges edges &lt;- net$edges edges$id &lt;- seq(1, nrow(edges)) # Visualise sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) Remember the workflow of the twinetverse: We collect the data We build the graph We visualise the network References "],
["advanced.html", "Chapter 6 Advanced 6.1 Collect 6.2 Build 6.3 Visualise", " Chapter 6 Advanced In this chapter we essentially replicate what we did in the Get Started chapter but in a somewhat more advanced manner as we introduce new functions and arguments. 6.1 Collect Let’s collect more tweets this time, we’ll also optimise our Twitter query. This is very useful as the Twitter API (like the vast majority of APIs) limits the amount of data you can access by imposing a rate limit. We set include_rts = FALSE as we don’t need the same tweet multiple times, it does not add information to our graph (currently but it could). We also pass a slightly more sophisticated query to the search tweet endpoint. This is too often overlooked, the Twitter API provides advanced operators: you are not limited to searching a single keyword every time. We query 1,000 tweets that: Include #rstats Include a mention i.e.: @jdatap Are original (not re-tweets) Remember to load your token if you’re in a new environment. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 1000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 6.2 Build Let’s build the graph, just like we did before. There is more to graphTweets but we won’t look into that just yet. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id) %&gt;% gt_nodes() %&gt;% gt_collect() 6.3 Visualise Let’s make a slightly more interesting visualisation this time. First, we’ll prepare the data for sigmajs like we did in the get started chapter. library(dplyr) nodes &lt;- net$nodes edges &lt;- net$edges nodes &lt;- nodes %&gt;% arrange(n_edges) %&gt;% mutate( id = nodes, label = nodes, size = n_edges ) edges$id &lt;- seq(1, nrow(edges)) Now onto the visualisation. We add labels that will display on hover. We color the nodes by cluster. We layout the graph appropriately using one of igraph’s (file. 2018) many layout algorithms. We use sigmajs’ settings to change the edges color. # Visualise sigmajs(&quot;webgl&quot;) %&gt;% sg_nodes(nodes, id, label, size) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_cluster( colors = c( &quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot; ) ) %&gt;% sg_settings( minNodeSize = 1, maxNodeSize = 2.5, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) ## Found # 268 clusters Already looking better. References "],
["hashtags.html", "Chapter 7 Hashtags", " Chapter 7 Hashtags The twinetverse, or graphTweets more specifically, not only enables visualising interactions between users, it also lets one build and visualise networks of users and the hashtag(s) they use. Let’s collect some tweets, since we want to plot relationships between users and hashtags we’ll specify two hashtags: #python and #rstats. This way we’ll be able to see who uses both or either. Moreover it shows another Twitter API search operator. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats OR #python&quot;, n = 1000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! Now let’s build a network of hashtags to visualise which user tweets which #hashtag. net &lt;- tweets %&gt;% gt_edges_hash(hashtags, screen_name) %&gt;% gt_nodes() %&gt;% gt_collect() Let’s inspect the edges first. head(net$edges) source target n_tweets _abichat #cogugaison 1 _abichat #rr2018 5 _abichat #rstats 6 _abichat #rstatsfr 4 _abichat #tidyverse 1 _ColinFay #rr2018 1 The edges include the n_tweets variable which is the number tweets the #hashtag is found in. Note that in order to ensure we can always distinguish between a user and a hashtag, hashtag are preceded by the the # signs. Let’s take a look at the nodes. head(net$nodes) nodes type n_edges #پایتون hashtag 1 #アビトラ hashtag 1 #エアドロ hashtag 1 #エアドロップ hashtag 1 #チャットボット hashtag 1 #ネットワークエンジニアの小学校 hashtag 1 Nodes also include the type which is either set to user or hashtag. Only one function changes, we use gt_edges_hash instead of gt_edges. While the latter builds networks of users, as we should be somewhat familiar with already, the former build networks that map users to the hashtags they use in their tweets, it thus make sense to pass hashtags instead of text as rtweet neatly extracts that for us. Now onto the visualisation. As we did before, we unpack our network, using the zeallot package [R-zeallot] for a change, then we rename some variables to fit sigmajs’ expectation, and we color the nodes according to the type, whether it is a #hashtag or a @user. library(zeallot) c(edges, nodes) %&lt;-% net prep_edges &lt;- function(x){ x$id &lt;- seq(1, nrow(x)) return(x) } prep_nodes &lt;- function(x){ x$id &lt;- x$nodes x$label &lt;- x$nodes x$size &lt;- x$n_edges x$color &lt;- ifelse(x$type == &quot;user&quot;, &quot;#0084b4&quot;, &quot;#1dcaff&quot;) return(x) } nodes &lt;- prep_nodes(nodes) edges &lt;- prep_edges(edges) In the visualisation we add sg_neighbours to highlight nodes and its neighbours on click. sigmajs() %&gt;% sg_nodes(nodes, id, size, color, label) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_settings( edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) %&gt;% sg_neighbours() It is interesting to see that few users actually tweet both hashtags, this wouldn’t have to be in the same tweet so it is somewhat surprising. "],
["dynamic.html", "Chapter 8 Dynamic 101 8.1 Rationale 8.2 Collect 8.3 Build 8.4 Visualise", " Chapter 8 Dynamic 101 So far we have been drawing static graphs, in this chapter we look at dynamic ones, namely temporal. 8.1 Rationale We’ve been visualising Twitter interactions in a static manner, but they are dynamic when you think of it. Twitter conversations happen over time, thus far, we’ve been drawing all encompassing snapshots. So let’s take into account the time factor to make a tempral graphs. 8.2 Collect We’ll collect some tweets again, but feel free to use previously collected tweets; nothing changes at this stage. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 5000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 8.3 Build Now onto building the graph. net &lt;- tweets %&gt;% gt_edges(text, screen_name, status_id, created_at = &quot;created_at&quot;) %&gt;% gt_nodes() %&gt;% gt_dyn() %&gt;% gt_collect() Quite a few things differ from previous graphs we have built. We pass created_at in gt_edges. This in effect adds the created_at column to our edges, so that we know the created time of post in which the edge appears. We use gt_dyn which stands for dynamic, which essentially computes the time at which edges and nodes should appear and disappear. head(net$edges) source target created_at end ma_salmon DavidGohel 2018-07-06 09:38:02 2018-07-06 09:38:02 ma_salmon StatnMap 2018-07-06 08:10:48 2018-07-06 09:38:02 ma_salmon DavidGohel 2018-07-06 09:34:29 2018-07-06 09:38:02 ma_salmon oodmansasha 2018-07-06 09:34:29 2018-07-06 09:38:02 ma_salmon uliasilge 2018-07-06 09:34:29 2018-07-06 09:38:02 ma_salmon OpenSci 2018-07-06 09:34:29 2018-07-06 09:38:02 8.4 Visualise Now for the visualisation, let’s build it step by step; first we prep the data as we did before: renaming a few columns but also running a few unfamiliar computations. To explain we need to tackle how edges will dinamically appear on the graph. The way this works in sigmajs is by specifying the delay in milliseconds before each respective edge should be added. Therefore, we need to transform the date to milliseconds and rescale them to be within a reasonable range: we don’t want the edges to actually take 15 days to appear on the graph. We change the date (POSIXct actually) to a numeric which gives the number of milliseconds since 1970. We rescale between 0 and 1 then multiply by 10,000 (milliseconds) so that the edges are added over 10 seconds. library(dplyr) library(zeallot) c(edges, nodes) %&lt;-% net # unpack nodes &lt;- nodes %&gt;% mutate( id = source, label = source, size = n_edges ) %&gt;% select(id, label, size) edges &lt;- edges %&gt;% mutate( id = 1:n(), created_at = as.numeric(created_at), created_at = (created_at - min(created_at)) / (max(created_at) - min(created_at)), created_at = created_at * 10000 ) %&gt;% select(id, source, target, created_at) Now, the actual visualisation, as mentioned at the begining to the chapter, we’ll plot the nodes then add edges dynamically. Let’s break it down step by step. First, we plot the nodes. sigmajs() %&gt;% sg_nodes(nodes, id, size, label) We’ll add the layout as it looks a bit messy with nodes randomly scattered across the canvas. We’ll have to compute the layout differently this time, we cannot simply use sg_layout as it requires both nodes and edges and we only have nodes on the graph; instead we use sg_get_layout. This is something that we had not shared with you earlier on, sg_nodes must have x and y coordinates of each node, however, if missing they are generated randomly by the package. We simply compute those coordinates then bind them to our nodes. layout &lt;- sg_get_layout(nodes, edges) nodes &lt;- nodes %&gt;% bind_cols(layout) head(nodes) id label size x y (???) (???) 1 118.764045 -55.41490 __jsta’s __jsta’s 1 -158.925024 -67.72065 _abichat _abichat 26 28.794156 -34.29772 _arnaudr _arnaudr 1 138.605808 -70.12058 _ColinFay _ColinFay 13 17.014188 -46.60126 _ColinFayhttps//tco/m0mMlOxdw2 _ColinFayhttps//tco/m0mMlOxdw2 1 7.547689 -11.58734 Now we can simply pass the coordinates x and y to sg_nodes. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) Let’s beautify the graph a little, this deep black is somewhat unnerving. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Now we have something that looks like a graph, except it’s missing edges. Let’s add them. We add the edges almost exactly as we did before, we use sg_add_edges instead of sg_edges. Other than the function name, the only difference is that we pass created_at as delay. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Now the edges appear dynamically. However you probably missed that as the animation is triggered when the page is loaded. sigmajs provides an easy workaround: we can add a button for the user to trigger the animation themself. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_button(&quot;Add edges&quot;, &quot;add_edges&quot;) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) "],
["references.html", "References", " References "]
]

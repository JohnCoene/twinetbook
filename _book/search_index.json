[
["index.html", "The twinetverse Visualise Networks of Twitter Interactions Chapter 1 Preface", " The twinetverse Visualise Networks of Twitter Interactions John Coene 2019-04-13 Chapter 1 Preface The goal of the twinetverse is to provide everything one might need to view Twitter interactions, from data collection to visualisation. The twinetverse package is available on Github and Bitbucket. devtools::install_bitbucket(&quot;JohnCoene/twinetverse&quot;) remotes::install_github(&quot;JohnCoene/twinetverse&quot;) The package is unlikely to make it onto CRAN, it may be considered once all of its children packages are on the archive network, but not until then. The source code for this book can be found on Github. You can suggest edits to this book by highlighting a section and annotate the text. "],
["intro.html", "Chapter 2 Introduction 2.1 Packages", " Chapter 2 Introduction 2.1 Packages The twinetverse includes three packages: rtweet (Kearney 2018) graphTweets (Coene 2019a) sigmajs (Coene 2019b) Within the context of visualising Twitter interactions, each of the packages listed above fill in a specific need and a distinct step of the process, 1) collecting the data, 2) building the graphs and finally 3) visualising the graphs of said interactions. In the next chapter, we look at the packages that make up the twinetverse in more depth. References "],
["pkgs.html", "Chapter 3 Packages 3.1 rtweet 3.2 graphTweets 3.3 sigmajs", " Chapter 3 Packages Below are the packages that make up in the twinetverse as well as some explanation of what they bring to visualising Twitter interactions. Though considered a package the ’verse itself only comes with two functions, all the other functions we’ll use in this book are part of the packages detailed below. 3.1 rtweet If we are going to visualise Twitter interactions we are going to need data, namely tweets. The rtweet package (Kearney 2018) wraps the Twitter API, thereby giving R users easy access to tweets. From the official website: [rtweet is an] R client for accessing Twitter’s REST and stream APIs 3.1.1 Usage rtweet fills the very first step in visualising Twitter interactions, collecting the necessary data. Note that the package lets you do much more than simply downloading tweets, however, within the twinetverse, this is its main function. 3.2 graphTweets 3.2.1 Rationale The graphTweets package (Coene 2019a) lets you extract nodes and edges from tweets collected with rtweet. The package is fairly straighforward as it inludes just a few functions. However, it still enables you to build relatively complex graphs. The package revolves around two core functions which respectively allow you to build data.frames of edges and nodes. These edges and nodes (also referred to as vertices) together map Twitter conversations by linking the sender of a tweet to the user(s) he or she @tags. Though the package also allows returning igraph objects (file. (2019)) this is not necessary in the twinetverse, and therefore not demonstrated in this book. More information is available on the package’s official website. 3.2.2 Usage All functions of the package start with gt_. graphTweets fills the second step in visualising Twitter interactions, building the graphs from the collected data. 3.3 sigmajs The sigmajs package (Coene 2019b) is a powerful library to visualise the networks we have built using graphTweets. The package, like graphTweets, is pipe-friendly (%&gt;%), therefore making it easy to go from building a graph to visualising it. It can also easily represent dynamic networks, something otherwise not evident in R. Features: Highly interactive Crosstalk integrated Includes Shiny proxies Events in Shiny Buttons to trigger interactions. and more. 3.3.1 Usage All functions of the package start with sg_. sigmajs is the final piece of the puzzle, visualising the graphs we have built. References "],
["prerequisites.html", "Chapter 4 Prerequisites 4.1 Install 4.2 Setup rtweet", " Chapter 4 Prerequisites In this chapter we get you set up and running with the twinetverse, namely the package installation and setting up rtweet to fetch tweets. 4.1 Install The package can be installed with devtools (Wickham, Hester, and Chang 2018) or remotes (Csárdi et al. 2018), it is available from Github or Bitbucket: The twinetverse package can be installed from Github: devtools::install_github(&quot;JohnCoene/twinetverse&quot;) or from Bitbucket: remotes::install_bitbucket(&quot;JohnCoene/twinetverse&quot;) In the book we don’t explicitly load the package and assume you have it loaded in your environment. library(twinetverse) 4.2 Setup rtweet The rtweet package requires some set up. This is not only extremely easy but also very well explained on rtweet’s official website, so head over there if the short description below does not satisfy. In essence, you will need a Twitter “app” to access its API, to create one: Head over to apps.twitter.com and login or signup if you do not have a Twitter account. Click create an app. In the following form, enter an app name, whatever you want, this does not matter. Enter a description, then again, it doesn’t matter. Website, simply put a valid website, you can link to your Twitter profile if you do not have one, i.e.: https://twitter.com/jdatap Callback URL, this is important, in there put the following: http://127.0.0.1:1410, exactly as is. You’re now setup with an app, take note of the crendentials of your app under “Keys and Access Tokens”, as you will need it to create your token and fetch tweets: Consumer Key (consumer_key) Consumer Secret (consumer_secret) Access Token (access_token) Access Token Secret (access_secret) Do NOT share those credentials or your token with anyone. Create your token with like so. # library(twinetverse) TK &lt;- create_token( &quot;My Application Name&quot;, consumer_key = &quot;XxxxXxXXxXx&quot;, consumer_secret = &quot;XxxxXxXXxXx&quot;, access_token = &quot;XxxxXxXXxXx&quot;, access_secret = &quot;XxxxXxXXxXx&quot; ) Ideally, also save it. There is no need to re-create a token everytime you want to download data. Once saved you can easily load it readRDS (we’ll demonstrate that in the next chapter). saveRDS(TK, file = &quot;token.rds&quot;) You’re all set to use the twinetverse! References "],
["graphs.html", "Chapter 5 Graphs 5.1 Anatomy 5.2 Types", " Chapter 5 Graphs Before we get on with the graphs let’s go through the types of graphs that the twinetverse, through graphTweets, allows you to build. 5.1 Anatomy To explain the graphs let’s first look at the anatomy of a basic tweet. Introducing the #rstats {twinetverse} package; everything you need to collect, build, and visualise #twitter interactions. In depth documentation thanks to @xieyihui {bookdown}: https://t.co/Sf5WdI8m6p pic.twitter.com/GxDSeWpqJL — John Coene (@jdatap) July 26, 2018 The above tweet is posted by a user (@jdatap), the tweet uses a hashtag (#rstats and #twitter) and @tags another user (@xieyihui, the creator of bookdown (Xie 2018) which is used to write this very book). #hashtags and @users are the core components of tweets that the twinetverse looks into. 5.2 Types 5.2.1 1. Conversations If we were to try to understand how users communicate with one another on a given topic, we could build a graph where each user is a node (disk/point), which are linked together (edges) when one has @tagged another in a tweet. Thereby visualising who discusses with who. So using our tweet above as example: @jdatap -&gt; @xieyihui. 5.2.2 2. Retweets Using retweets we can understand how information spreads throughout the Twitter network. In this graph, each node is a user who is connected to other users who he retweeted. 5.2.3 3. Co-mentions We can also build networks of co-mentions, for both users and hashtags. On these networks, nodes are connected when they are mentioned together in the same tweet. This reveals clusters (of users or hashtags) A network of hashtags co-mentions with our tweet above would result in: #rstats -&gt; #twitter. Conversations and Retweets graphs (1, 2) are directed while co-mentions (3) are undirected. Finally, graphTweets provides functions to bind edges together, so you can combine any the of the networks mentioned above. We will explore all of the graphs discussed here throughout the book. References "],
["get-started.html", "Chapter 6 Get Started 6.1 Collect 6.2 Build 6.3 Visualise 6.4 Recap 6.5 Improve", " Chapter 6 Get Started In this chapter we briefly explore the twinetverse: we collect tweets, build and visualise our first graph. The graphs are built with graphTweets (part of the ’verse) which allows building several kinds of graphs, most of which we will explore, however, we will start with a graph that attempts at depicting how users communicate with each other by looking at who @tags who in their tweets. If you follow this along in RStudio; the visualisations do not open in the viewer and instead open in your default browser. 6.1 Collect See the prerequisites section if the line below confuses you. TK &lt;- readRDS(&quot;token.rds&quot;) rtweet lets you do a lot of things, however within the context of the twinetverse we mainly use its search_tweets to get tweets. tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) ## Searching for tweets... ## Finished collecting tweets! The search_tweets function takes a few arguments some of which we’ll eventually get into, above we run the simplest possible call; fetching tweets about “rstats”, a reference to the R (R Core Team 2019) Twitter #hashtag, by default the function returns 100 tweets. Note that we also pass our token to the function. Each row a is a tweet, rtweet returns quite a lot of variables (88), we’ll only look at a select few. names(tweets) ## [1] &quot;user_id&quot; &quot;status_id&quot; ## [3] &quot;created_at&quot; &quot;screen_name&quot; ## [5] &quot;text&quot; &quot;source&quot; ## [7] &quot;display_text_width&quot; &quot;reply_to_status_id&quot; ## [9] &quot;reply_to_user_id&quot; &quot;reply_to_screen_name&quot; ## [11] &quot;is_quote&quot; &quot;is_retweet&quot; ## [13] &quot;favorite_count&quot; &quot;retweet_count&quot; ## [15] &quot;hashtags&quot; &quot;symbols&quot; ## [17] &quot;urls_url&quot; &quot;urls_t.co&quot; ## [19] &quot;urls_expanded_url&quot; &quot;media_url&quot; ## [21] &quot;media_t.co&quot; &quot;media_expanded_url&quot; ## [23] &quot;media_type&quot; &quot;ext_media_url&quot; ## [25] &quot;ext_media_t.co&quot; &quot;ext_media_expanded_url&quot; ## [27] &quot;ext_media_type&quot; &quot;mentions_user_id&quot; ## [29] &quot;mentions_screen_name&quot; &quot;lang&quot; ## [31] &quot;quoted_status_id&quot; &quot;quoted_text&quot; ## [33] &quot;quoted_created_at&quot; &quot;quoted_source&quot; ## [35] &quot;quoted_favorite_count&quot; &quot;quoted_retweet_count&quot; ## [37] &quot;quoted_user_id&quot; &quot;quoted_screen_name&quot; ## [39] &quot;quoted_name&quot; &quot;quoted_followers_count&quot; ## [41] &quot;quoted_friends_count&quot; &quot;quoted_statuses_count&quot; ## [43] &quot;quoted_location&quot; &quot;quoted_description&quot; ## [45] &quot;quoted_verified&quot; &quot;retweet_status_id&quot; ## [47] &quot;retweet_text&quot; &quot;retweet_created_at&quot; ## [49] &quot;retweet_source&quot; &quot;retweet_favorite_count&quot; ## [51] &quot;retweet_retweet_count&quot; &quot;retweet_user_id&quot; ## [53] &quot;retweet_screen_name&quot; &quot;retweet_name&quot; ## [55] &quot;retweet_followers_count&quot; &quot;retweet_friends_count&quot; ## [57] &quot;retweet_statuses_count&quot; &quot;retweet_location&quot; ## [59] &quot;retweet_description&quot; &quot;retweet_verified&quot; ## [61] &quot;place_url&quot; &quot;place_name&quot; ## [63] &quot;place_full_name&quot; &quot;place_type&quot; ## [65] &quot;country&quot; &quot;country_code&quot; ## [67] &quot;geo_coords&quot; &quot;coords_coords&quot; ## [69] &quot;bbox_coords&quot; &quot;status_url&quot; ## [71] &quot;name&quot; &quot;location&quot; ## [73] &quot;description&quot; &quot;url&quot; ## [75] &quot;protected&quot; &quot;followers_count&quot; ## [77] &quot;friends_count&quot; &quot;listed_count&quot; ## [79] &quot;statuses_count&quot; &quot;favourites_count&quot; ## [81] &quot;account_created_at&quot; &quot;verified&quot; ## [83] &quot;profile_url&quot; &quot;profile_expanded_url&quot; ## [85] &quot;account_lang&quot; &quot;profile_banner_url&quot; ## [87] &quot;profile_background_url&quot; &quot;profile_image_url&quot; 6.2 Build Now we can use the second package part of the twinetverse, graphTweets. Again, we’ll leave all function’s arguments to default to get a simple graph. There’s a lot more to the package which we’ll uncover progressively as we move through the book. There are two ways of building a network of Twitter users with graphTweets, the one we use in this book is preferable over the other as it is much more accurate. The more accurate gt_edges based on mentions_screen_name (names of users @tagged in tweets) provided by the Twitter API. The less accurate gt_edges_from_text which extracts the @tagged users from the tweets’ text, essentially the same as mentions_screen_name but likely less accurate. net &lt;- tweets %&gt;% gt_edges(source = screen_name, target = mentions_screen_name) We called gt_edges on our tweets data.frame, passing a few bare column names. The source of the tweets (the user posting the tweets) will also be the source of our edges so we pass source = screen_name, then the target of these edges will be users @tagged in the tweets, which is given by the API as mentions_screen_name; this will be target of our edges. The object returned is of an unfamiliar class. class(net) ## [1] &quot;graphTweets&quot; To extracts the results from graphTweets run gt_collect, this will work at any point in the chain of pipes (%&gt;%). net &lt;- net %&gt;% gt_collect() class(net) ## [1] &quot;list&quot; Great but this returns a lists and R users much prefer data.frames. graphTweets actualy returns two data.frames that are encapsulated in a list. Indeed networks cannot be compressed into a single data.frame, we need 1) nodes and 2) edges. names(net) ## [1] &quot;edges&quot; &quot;nodes&quot; A network consists of nodes and edges: this is just what graphTweets returns. Great, so it looks like we have both nodes and edges, not really. We only have edges, net$nodes is actually NULL. lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;NULL&quot; Well, we only ran gt_edges so it make sense to only have edges. Let’s scrap that and get both nodes and edges. net &lt;- tweets %&gt;% gt_edges(screen_name, mentions_screen_name) %&gt;% # get edges gt_nodes() %&gt;% # get nodes gt_collect() # collect lapply(net, class) ## $edges ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; ## ## $nodes ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Before we move on, something to note. graphTweets requires that you run the functions in the correct order, first gt_edges and second gt_nodes. This is because one can only know the nodes of a graph based on the edges and not vice versa. Run graphTweets’ functions in the correct order, first get the edges then the nodes. Now we’re ready to visualise the data, we have downloaded tweets used them to build a of nodes and another of edges. 6.3 Visualise We can visualise the network with sigmajs. Then again, it’s very easy and follows the same idea as graphTweets; we pipe our nodes and edges through. Before we do so, for the sake of clarity, let’s unpack our network using the %&lt;-% from the Zeallot package (Teetor 2018), imported by the twinetverse. c(edges, nodes) %&lt;-% net You can always unpack the network with edges &lt;- net$edges and nodes &lt;- net$nodes if you are not comfortable with the above. Let’s take a look at the edges. head(edges) source target n _alejandro_aa fsdeviation 1 adanventas jlopezper 1 alex_danvers jinxgoh 1 alex_danvers sachaepskamp 1 andremrsantos dataquestio 1 anh_n_tran clauswilke 1 Edges simply consist of source and target, as explained earlier on, source essentially corresponds to screen_name passed in gt_edges, it is the user who posted the tweet. In contrast, target includes the users that were tagged in the text of the tweet. The n variable indicates how many tweets connect the source to the target. Now let’s take a look at the nodes: head(nodes) nodes type n _alejandro_aa user 1 _colinfay user 5 adanventas user 1 alex_danvers user 2 andremrsantos user 1 andrewheiss user 2 In the nodes data frame, the column n is the number of times the node appears (whether as source or as target), while the nodes column are the Twitter handles of both the authors of the tweets (screen_name) and those who were @tagged in the tweets. All nodes are users of course, but we will see another graph later in the book where they may not be. Below we rename a few columns, to meet sigmajs’ naming convention. We add ids to our nodes, this can be a string and thus simply corresponds to our nodes column. We essentially rename n to size as this is what sigmajs understands. We add ids to our edges as sigmajs requires each edge to have a unique id. nodes$id &lt;- as.factor(nodes$nodes) nodes$size &lt;- nodes$n edges$id &lt;- seq(1, nrow(edges)) sigmajs has a specific but sensible naming convention as well as basic minimal requirements. Nodes must at least include id, and size. Edges must at least include id, source, and target. Well actually, the twinetverse comes with helper functions to prepare the nodes and edges build from graphTweets for use in sigmajs (these are the only functions the ’verse provides). nodes &lt;- nodes2sg(nodes) edges &lt;- edges2sg(edges) You need to respect sigmajs naming convention or the graph will not display. Let’s visualise that, we must initialise every sigmajs graph with the sigmajs function, then we add our nodes with sg_nodes, passing the column names we mentioned previously, id, and size to meet sigmajs’ minimum requirements. In sigmajs, at the exception of the function called sigmajs, all start with sg_ sigmajs() %&gt;% sg_nodes(nodes, id, size) sigmajs actually allows you to build graphs using only nodes or edges, we’ll see why this is useful in a later chapter on temporal graphs. Let’s add the edges. Then again, to meet sigmajs’ requirements, we pass id, source and target. sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) This graph does not look great. We’ll beautify that bit by bit as we move through the book: sigmajs is highly customisable. Nevermind beauty, what’s on the graph exactly? Each disk/point on the graph is a twitter user, they are connected when one has tagged the other in the a tweet. You may also notice that the graph contains surprisingly few nodes, given that we queried 100 tweets you would expect over 100 nodes on the graph. This is because our visualisation only includes tweets that mention other users and most tweets are not targeted (tagged) at other users. There is an easy remedy to this which we’ll look at in the next section. Remember the workflow of the twinetverse: We collect the data We build the graph We visualise the network 6.4 Recap Let’s recapitulate before moving on to the next section. The section may look long~ish but the code is not, here it is put together. library(dplyr) # COLLECT tweets &lt;- search_tweets(&quot;rstats&quot;, token = TK) # BUILD net &lt;- tweets %&gt;% gt_edges(screen_name, mentions_screen_name) %&gt;% gt_nodes() %&gt;% gt_collect() c(edges, nodes) %&lt;-% net # unpack # prepare for sigmajs nodes &lt;- nodes2sg(nodes) edges &lt;- edges2sg(edges) # VISUALISE sigmajs() %&gt;% sg_nodes(nodes, id, size) %&gt;% sg_edges(edges, id, source, target) 6.5 Improve Let’s collect more tweets this time, we’ll also optimise our Twitter query. This is very useful as the Twitter API (like the vast majority of APIs) limits the amount of data you can access by imposing a rate limit. You can always check where you stand with the various Twitter rate limits with rate_limit(). We set include_rts = FALSE as we don’t need the same tweet multiple times, it does not add information to our graph (currently but it could). We also pass a slightly more sophisticated query to the search tweet endpoint. This is too often overlooked, the Twitter API provides advanced operators: you are not limited to searching a single keyword every time. Optimise your queries or you’ll be hit by frustrating waiting times. We query 1,000 tweets that: Include #rstats Include a mention i.e.: @jdatap Are original (not re-tweets) Remember to load your token if you’re in a new environment. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 1000, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! Let’s build the graph, just like we did before. There is more to graphTweets but we won’t look into that just yet. net &lt;- tweets %&gt;% gt_edges(screen_name, mentions_screen_name) %&gt;% gt_nodes() %&gt;% gt_collect() Let’s make a slightly more interesting visualisation this time. First, we’ll prepare the data for sigmajs like we did in the get started chapter. c(edges, nodes) %&lt;-% net nodes &lt;- nodes2sg(nodes) edges &lt;- edges2sg(edges) Now onto the visualisation. We add labels that will display on hover by simply passing the label column to sg_nodes. We color the nodes by cluster with sg_cluster. We layout the graph appropriately using one of igraph’s (file. 2019) many layout algorithms with sg_layout. We use sigmajs’ settings to change the edges color. sigmajs(&quot;webgl&quot;) %&gt;% sg_nodes(nodes, id, label, size) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_cluster( colors = c( &quot;#0075a0&quot;, &quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot; ) ) %&gt;% sg_settings( minNodeSize = 1, maxNodeSize = 2.5, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) ## Found # 276 clusters Already looking better. References "],
["retweets.html", "Chapter 7 Retweets 7.1 Collect 7.2 Build 7.3 Visualise", " Chapter 7 Retweets Thus far we built graphs that link the user tweeting to the users he or she @tags in his or her tweets. This type of network, in essence, visualise how people discuss certain issues. We can build another graph, linking users to the users they retweet to fundamentally visualise how information spreads throughout Twitter. 7.1 Collect We will run a slightly different query to collect tweets. Since we want to focus on re-tweets let’s ensure the tweets we collect include re-tweets. # TK &lt;- readRDS(&quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:retweets&quot;, n = 500, include_rts = TRUE, token = TK) ## Searching for tweets... ## Finished collecting tweets! 7.2 Build In previous graphs we set target = mentions_screen_name, the only difference this time is that we pass target = retweet_screen_name. net &lt;- tweets %&gt;% gt_edges(screen_name, retweet_screen_name) %&gt;% # get edges gt_nodes() %&gt;% # get nodes gt_collect() # collect c(edges, nodes) %&lt;-% net 7.3 Visualise Regarding the visualisation not much changes. We have the nodes and edges as returned by graphTweets, now we just need to pipe them through our sigmajs functions to build up the visualisation. nodes &lt;- nodes2sg(nodes) edges &lt;- edges2sg(edges) sigmajs() %&gt;% sg_nodes(nodes, id, label, size) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_cluster( colors = c( &quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot; ) ) %&gt;% sg_settings( minNodeSize = 1, maxNodeSize = 2.5, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) ## Found # 49 clusters So, based on the retweet networks, the larger nodes, that are relatively closer to the center of the graph (centrality measure) are relatively more important to spreading the topic we searched: #rstats. "],
["hashtags.html", "Chapter 8 Hashtags 8.1 Collect 8.2 Build 8.3 Visualise", " Chapter 8 Hashtags The twinetverse, or graphTweets more specifically, not only enables visualising interactions between users, it also lets one build and visualise networks of users and the hashtag(s) they use as well as network of hashtags co-mentions. Let’s first look at connecting users to the hashtags they use. 8.1 Collect Let’s collect some tweets, since we want to plot relationships between users and hashtags we’ll specify two hashtags: #python and #rstats. This way we’ll be able to see who uses both or either. We’ll also narrow it down to tweets in English to avoid #hashtags we cannot understand. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats OR #python&quot;, n = 1000, token = TK, include_rts = FALSE, lang = &quot;en&quot;) ## Searching for tweets... ## Finished collecting tweets! 8.2 Build Now let’s build a network of hashtags to visualise which user tweets which #hashtag. net &lt;- tweets %&gt;% gt_edges(screen_name, hashtags) %&gt;% gt_nodes() %&gt;% gt_collect() Let’s inspect the edges first. head(net$edges) source target n phpjobs #css 1 phpjobs #html5 1 phpjobs #js 1 phpjobs #mysql 1 phpjobs #php 1 phpjobs #python 1 The edges include the n_tweets variable which is the number tweets the #hashtag is found in. Note that in order to ensure we can always distinguish between a user and a hashtag, hashtag are preceded by the the # sign. Let’s take a look at the nodes. head(net$nodes) nodes type n phpjobs user 9 _andrew_nkhata user 2 _colinfay user 2 _testanic user 1 #100daysofcode hashtag 31 #100daysofmlcode hashtag 4 Nodes also include the type which is either set to user or hashtag. 8.3 Visualise Now onto the visualisation. As we did before, we unpack our network, then we prepare the data to fit sigmajs’ expectation, and we color the nodes according to the type, one colour for #hashtags and another for @users. c(edges, nodes) %&lt;-% net nodes &lt;- nodes2sg(nodes) edges &lt;- edges2sg(edges) nodes$color &lt;- ifelse(nodes$type == &quot;user&quot;, &quot;#0084b4&quot;, &quot;#1dcaff&quot;) In the visualisation we add sg_neighbours to highlight neighbours of the node clicked, try it. sigmajs() %&gt;% sg_nodes(nodes, id, size, color, label) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_settings( edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) %&gt;% sg_neighbours() It is interesting to see that few users actually tweet both hashtags, this wouldn’t have to be in the same tweet so it is somewhat surprising. "],
["co-mentions.html", "Chapter 9 Co-mentions 9.1 Users 9.2 Hashtags", " Chapter 9 Co-mentions The twinetverse also enables building networks of co-mentions. Say, instead of connecting users posting tweets to the @users they tag in their tweets or the #hashtags they mention in their tweets, we were to connect the #hashtags or the @users mentioned in the tweets to each other, not taking into account the person posting the tweet. Let’s collect some tweets for this chapter. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;rstats&quot;, n = 1000, token = TK, include_rts = FALSE, lang = &quot;en&quot;) ## Searching for tweets... ## Finished collecting tweets! 9.1 Users Building graphs of co-mentions requires the use of another function, from the graphTweets package. Instead of using gt_edges we use gt_co_edges, simple enough. Moreover since we ignore the source of the tweets, we only have to pass one argument to the function, the column containing the variable of which we want to to graph the co-mentions; hashtags, or mentions_screen_name. net &lt;- tweets %&gt;% gt_co_edges(mentions_screen_name) %&gt;% gt_nodes() %&gt;% gt_collect() c(edges, nodes) %&lt;-% net edges &lt;- edges2sg(edges) nodes &lt;- nodes2sg(nodes) Since we are going to graph more than one co-mention network, let’s define a graph function that we can easily re-use. sg_graph &lt;- function(nodes, edges){ sigmajs() %&gt;% sg_nodes(nodes, id, label, size) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_cluster( colors = c( &quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot; ) ) %&gt;% sg_force_start() %&gt;% sg_force_stop(2000) %&gt;% sg_neighbours() %&gt;% sg_settings( defaultEdgeColor = &quot;#a3a3a3&quot;, edgeColor = &quot;default&quot; ) } sg_graph(nodes, edges) ## Found # 70 clusters 9.2 Hashtags Now let’s do the same as we did in the previous section but using #hashtags, make the graph and plot the result. net &lt;- tweets %&gt;% gt_co_edges(hashtags) %&gt;% gt_nodes() %&gt;% gt_collect() c(edges, nodes) %&lt;-% net edges &lt;- edges2sg(edges) nodes &lt;- nodes2sg(nodes) sg_graph(nodes, edges) ## Found # 35 clusters It’s obviously not as informative as the previous graph we made, there is a simple reason. Since we got tweets on #rstats all hashtags co-mention #rstats and are thus connected to it on the graph. This is a known piece of information and clutters the graph, let’s remove it. edges &lt;- edges %&gt;% edges2sg() %&gt;% dplyr::filter( source != &quot;#rstats&quot;, target != &quot;#rstats&quot; ) nodes &lt;- nodes %&gt;% nodes2sg() %&gt;% dplyr::filter( id != &quot;#rstats&quot; ) Now that the filtering is done we can plot the data. Remember to filter both edges and nodes. sg_graph(nodes, edges) ## Found # 166 clusters "],
["advanced.html", "Chapter 10 Advanced", " Chapter 10 Advanced At this point, if you have read the book up to here, you have been explored all the difference types of graphs that we can build with the twinetverse. Now we can introduce two more functions to bind edges together and form more complex graphs. Let’s take two of our previous graphs and merge them into one. Let’s build a graph where we not only connect users to the hashtags they use but also connect the hashtags used in the same tweets together. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats&quot;, n = 1000, token = TK, include_rts = FALSE, lang = &quot;en&quot;) ## Searching for tweets... ## Finished collecting tweets! Technically, the two graphs we want to merge are below. # Users to hashtags users &lt;- tweets %&gt;% gt_edges(screen_name, hashtags) %&gt;% gt_nodes() %&gt;% gt_collect() # hashtags co-mentions hashtags &lt;- tweets %&gt;% gt_co_edges(hashtags) %&gt;% gt_nodes() %&gt;% gt_collect() Building two graphs, as above, to then merge them into one would not be convienient. It works differently in graphTweets, we do not need to build two full graphs, we only need to bind edges together and thus can do it in one single pipe (%&gt;%). net &lt;- tweets %&gt;% gt_edges(screen_name, hashtags) %&gt;% gt_co_edges_bind(hashtags) %&gt;% gt_nodes() %&gt;% gt_collect() We just call gt_co_edges_bind (in essence the same function as gt_co_edges) to bind those edges to previously piped edges. This would totally work the other way around too. net &lt;- tweets %&gt;% gt_co_edges(hashtags) %&gt;% gt_edges_bind(screen_name, hashtags) %&gt;% gt_nodes() %&gt;% gt_collect() You can unpack the network just as before. We’ll clean the graph a bit, remove the rstats hashtag and color the nodes by type (whether it is a user or hashtag). c(edges, nodes) %&lt;-% net edges &lt;- edges2sg(edges) nodes &lt;- nodes2sg(nodes) edges &lt;- edges %&gt;% edges2sg() %&gt;% dplyr::filter( source != &quot;#rstats&quot;, target != &quot;#rstats&quot; ) nodes &lt;- nodes %&gt;% nodes2sg() %&gt;% dplyr::filter( id != &quot;#rstats&quot; ) nodes$color &lt;- ifelse(nodes$type == &quot;user&quot;, &quot;#0084b4&quot;, &quot;#1dcaff&quot;) sigmajs() %&gt;% sg_nodes(nodes, id, label, size, color) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_neighbours() %&gt;% sg_layout(layout = igraph::layout_components) %&gt;% sg_settings( minNodeSize = 1, maxNodeSize = 2.5, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;rgba(211, 211, 211, 0.4)&quot; ) You can technically bind any edges together. However, be careful that the resulting graph still makes sense. For instance, binding two networks of co-mentions, one of hashtags and another of users, would result in two entirely separate graph as none of the users are connected to hashtags or vice verse. "],
["dynamic.html", "Chapter 11 Dynamic Edges 11.1 Rationale 11.2 Collect 11.3 Build 11.4 Visualise", " Chapter 11 Dynamic Edges So far we have been drawing static graphs, in this chapter we look at dynamic ones, namely temporal. However, being an introduction we’ll start with dynamic edges only: we’ll plot the nodes and have the edges appear dynamically .We’ll tackle the fully temporal network further down the book. 11.1 Rationale We’ve been visualising Twitter interactions in a static manner, but they are dynamic when you think of it. Twitter conversations happen over time, thus far, we’ve just been drawing all encompassing snapshots. So let’s take into account the time factor to make a where the edges appear at different time steps. 11.2 Collect We’ll collect some tweets again, we’ll use retweets this time, so we build the corresponding search. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:retweets&quot;, n = 400, token = TK, include_rts = TRUE) ## Searching for tweets... ## Finished collecting tweets! 11.3 Build Now onto building the graph. net &lt;- tweets %&gt;% gt_edges(screen_name, mentions_screen_name, created_at) %&gt;% gt_nodes() %&gt;% gt_dyn() %&gt;% gt_collect() Quite a few things differ from previous graphs we have built. We pass created_at in gt_edges. This in effect adds the created_at column to our edges, so that we know the created time of post in which the edge appears. We use gt_dyn which stands for dynamic, to essentially compute the time at which edges and nodes should appear on the graph. head(net$edges) source target created_at n end _alejandro_aa fsdeviation 2019-04-13 18:04:29 1 2019-04-13 19:01:04 _digitalpreneur neptanum 2019-04-13 16:51:58 1 2019-04-13 19:01:04 _digitalpreneur neptanum 2019-04-13 16:51:59 1 2019-04-13 19:01:04 _digitalpreneur neptanum 2019-04-13 16:52:22 1 2019-04-13 19:01:04 _reactdev gp_pulipaka 2019-04-13 17:17:16 1 2019-04-13 19:01:04 _reactdev neptanum 2019-04-13 16:47:16 3 2019-04-13 19:01:04 11.4 Visualise Now for the visualisation, let’s build it step by step; first we prep the data as we did before: renaming a few columns but also running a few unfamiliar computations. To explain how we build the visualisation, we first need to tell you how the edges will dynamically appear on the graph. The way this works in sigmajs is by specifying the delay in milliseconds before each respective edge should be added. Therefore, we need to transform the date to milliseconds and rescale them to be within a reasonable range: we don’t want the edges to actually take 15 days to appear on the graph. We change the date time column (POSIXct actually) to a numeric, which gives the number of milliseconds since 1970. We rescale between 0 and 1 then multiply by 10,000 (milliseconds) so that the edges are added over 10 seconds. library(dplyr) c(edges, nodes) %&lt;-% net # unpack nodes &lt;- nodes2sg(nodes) edges &lt;- edges %&gt;% mutate( id = 1:n(), created_at = as.numeric(created_at), created_at = (created_at - min(created_at)) / (max(created_at) - min(created_at)), created_at = created_at * 10000 ) %&gt;% select(id, source, target, created_at) Let’s inspect what we obtain. head(net$edges) id source target created_at 1 _alejandro_aa fsdeviation 6689.743 2 _digitalpreneur neptanum 2447.348 3 _digitalpreneur neptanum 2448.323 4 _digitalpreneur neptanum 2470.749 5 _reactdev gp_pulipaka 3927.457 6 _reactdev neptanum 2172.387 We see that the column created_at has changed from Date time (POSIXct) to a numeric. As mentioned previously, we rescaled it to be between 0 and 10,000 milliseconds, let’s see if that is correct. range(edges$created_at) ## [1] 0 10000 So for instance the edge at row 25, a tweet where @agnesoshiro tags @datacamp will appear after 308 milliseconds. edges[25,] ## # A tibble: 1 x 4 ## id source target created_at ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 25 agnesoshiro datacamp 308. Now, the actual visualisation, as mentioned at the begining to the chapter, we’ll plot the nodes then add edges dynamically. Let’s break it down step by step. First, we plot the nodes. sigmajs() %&gt;% sg_nodes(nodes, id, size, label) We’ll add the layout as it looks a bit messy with nodes randomly scattered across the canvas. We’ll have to compute the layout differently this time, we cannot simply use sg_layout as it requires both nodes and edges and we only have nodes on the graph (since edges are to be added later on, dynamically); instead we use sg_get_layout. You cannot use sg_cluster and sg_layout in dynamic graphs as they require both nodes and edges, use the sg_get_* alternatives. This is something that we had not shared with you earlier on, sg_nodes must have x and y coordinates of each node, however, if missing they are generated randomly by the package. sg_get_layout computes the coordinates of the nodes (x and y) and adds them to our nodes data.frame. nodes &lt;- sg_get_layout(nodes, edges, layout = igraph::layout_components) head(nodes) id label start end type size x y __m_pereira __m_pereira 2019-04-13 17:18:16 2019-04-13 19:01:04 user 1 22.233775 8.0232607 _alejandro_aa _alejandro_aa 2019-04-13 18:04:29 2019-04-13 19:01:04 user 1 3.182132 -0.5807958 _colinfay _colinfay 2019-04-13 16:49:30 2019-04-13 19:01:04 user 10 3.027288 0.8495334 _digitalpreneur _digitalpreneur 2019-04-13 16:51:58 2019-04-13 19:01:04 user 3 4.316311 3.0386541 _reactdev _reactdev 2019-04-13 16:47:16 2019-04-13 19:01:04 user 4 6.285060 4.5129124 _therealdant _therealdant 2019-04-13 16:17:33 2019-04-13 19:01:04 user 3 2.268359 20.1752716 Now we can simply pass the coordinates x and y to sg_nodes. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) Let’s beautify the graph a little, this deep black is somewhat unnerving. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Now we have something that looks like a graph, except it’s missing edges. Let’s add them. We add the edges almost exactly as we did before, we use sg_add_edges instead of sg_edges. Other than the function name, the only difference is that we pass created_at as delay. We also set cumsum to FALSE otherwise the function computes the cumulative sum on the delay, which is, here, our created_at column, and does not require counting the cumulative sum. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE, refresh = TRUE) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Now the edges appear dynamically. However you probably missed that as the animation is triggered when the page is loaded, the edges appear dynamically as you were reading this page. sigmajs provides an easy workaround: we can add a button for the user to trigger the animation themself. The button is added with sg_button to which we pass a label (Add edges) and the event (add_edges) the button will trigger. The name of the event corresponds to the function it essentially triggers minus the starting sg_. In our case add_edges triggers sg_add_edges. Many events can be triggered by the button, they are listed on sigmajs official website. Click the button in the top right corner of the visualisation to add the edges, it’ll take 10 seconds for all of them to be on the graph. sigmajs() %&gt;% sg_nodes(nodes, id, size, label, x, y) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE, refresh = TRUE) %&gt;% sg_button(&quot;add_edges&quot;, &quot;Add edges&quot;) %&gt;% sg_settings( defaultNodeColor = &quot;#127ba3&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot;, minNodeSize = 1, maxNodeSize = 4, minEdgeSize = 0.3, maxEdgeSize = 0.3 ) Add edges A sigmajs button can trigger multiple events. We can see that some nodes are better at diseminating the message (#rstats), as the message reaches them they trigger numerous re-tweets. "],
["temporal.html", "Chapter 12 Temporal 12.1 Collect 12.2 Build 12.3 Visualise", " Chapter 12 Temporal In the previous chapter we built a graph with dynamic edges. Let’s build a fully dynamic graph where both nodes and edges appear when they are first created. 12.1 Collect We again collect tweets in a slightly different manner but feel free to use data from a previous chapter. We specify type as mixed in order to get a mix of popular and recent tweets. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 300, token = TK, include_rts = FALSE, type = &quot;mixed&quot;) ## Searching for tweets... ## Finished collecting tweets! 12.2 Build We build the graph as we did in the previous chapter. net &lt;- tweets %&gt;% gt_edges(screen_name, mentions_screen_name, created_at) %&gt;% gt_nodes() %&gt;% gt_dyn() %&gt;% gt_collect() 12.3 Visualise Again, we unpack the network and prepare nodes and edges for our visualisation. Then we define a rescale functiion to ensure our treatment of the date time columns are consistent across nodes and edges. c(edges, nodes) %&lt;-% net #&#39; @param x Date time column. #&#39; @param t Number of milliseconds to rescale to. rescale &lt;- function(x, t){ x &lt;- as.numeric(x) x &lt;- (x - min(x)) / (max(x) - min(x)) x &lt;- x * t return(x) } rtweet returns date time but sigmajs expects milliseconds; it needs to be converted. Next we prepare the data, we define the t argument of our rescale function defined above as a constant so as to make sure we apply the same scale to both nodes and edges. library(dplyr) T &lt;- 10000 lockBinding(&quot;T&quot;, globalenv()) nodes &lt;- nodes %&gt;% nodes2sg() %&gt;% mutate( start = rescale(start, T) ) %&gt;% select(id, label, size, start) edges &lt;- edges %&gt;% mutate( id = 1:n(), created_at = as.numeric(created_at), created_at = rescale(created_at, T) ) %&gt;% select(id, source, target, created_at) Now the actual visualisation, then again, we set cumsum = FALSE, and add a button (linked to two events add_nodes and add_edges) to let you trigger the visualisation. before then you should see a blank canvas. sigmajs() %&gt;% sg_add_nodes(nodes, start, id, label, size, cumsum = FALSE) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_button(c(&quot;add_nodes&quot;, &quot;add_edges&quot;), &quot;Start&quot;) Start We forgot the layout and we do not color the nodes, let’s compute the layout and the clusters to color nodes. nodes &lt;- sg_get_layout(nodes, edges) nodes &lt;- sg_get_cluster( nodes, edges, colors = c( &quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot; ) ) ## Found # 110 clusters sigmajs() %&gt;% sg_add_nodes(nodes, start, id, label, size, color, x, y, cumsum = FALSE) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_button(c(&quot;add_nodes&quot;, &quot;add_edges&quot;), &quot;Start&quot;) Start So we transformed our date time to milliseconds and rescaled to span 10 seconds. The problem with this is that we, in a way, lose track of time in the visualisation itself. It’d be great to add a ticker to display, say, the date. Let’s explain how this is done in sigmajs; we simply create a table that maps dates to our milliseconds delay. To do so we extract the dates from our net object, we then rescale those dates just like we did for the nodes and edges. dates &lt;- as.Date(net$nodes$start) ticker &lt;- dplyr::tibble( dates = dates, delay = rescale(dates, T) ) %&gt;% arrange(delay) head(ticker) dates delay 2019-04-11 0.000 2019-04-12 1096.674 2019-04-13 6120.672 Now, how do we use this mapping table in sigmajs? sigmajs() %&gt;% sg_add_nodes(nodes, start, id, label, size, color, x, y, cumsum = FALSE) %&gt;% sg_add_edges(edges, created_at, id, source, target, cumsum = FALSE) %&gt;% sg_progress(ticker, delay, dates, cumsum = FALSE) %&gt;% sg_settings( edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) %&gt;% sg_button(c(&quot;add_nodes&quot;, &quot;add_edges&quot;, &quot;progress&quot;), &quot;Start&quot;) Start We use the sg_progress function to which we pass both the ticker columns’ variables and we tie that event to our button. "],
["ephemeral.html", "Chapter 13 Ephemeral 13.1 Collect 13.2 Build 13.3 Visualise 13.4 Dynamic layout", " Chapter 13 Ephemeral At this stage we’ve pretty much fully covered temporal graphs; nodes and edges appear over time on the graph. This already comes closer to reflecting reality if we assume that tweets are everlasting. In practice tweets have a life span; it is unlikely that old tweets from 2015 will be seen today. Therefore, on our graph, nodes and edges should appear then disappear after some time. We will cover an alternative/better way to have a dynamic layout in the next chapter. However, this chapter will let you get some great intuition on how to use the twinetverse. 13.1 Collect Let’s collect some tweets, just as we did previously. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 200, token = TK, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! 13.2 Build Just as we did in the temporal chapter, we’ll pass created_at so that we know when tweets are created (when edges and nodes should appear), with one difference: we specify lifetime in our gt_dyn function. We’ll also ease the work on our browser, constantly having to add and remove nodes and edges can be draining; we’ll round the time to the nearest hour. library(dplyr) net &lt;- tweets %&gt;% mutate( created_at = as.POSIXct(round(created_at, units = &quot;hours&quot;)) ) %&gt;% gt_edges(screen_name, mentions_screen_name, created_at) %&gt;% gt_nodes() %&gt;% gt_dyn(lifetime = (60 * 60 * 6)) %&gt;% gt_collect() The lifetime argument takes milliseconds, above, we set it 60 * 60 * 6 which is equal to 6 hours. As you might expect, we will rescale the timeframe as we did before but here we set the lifetime of a tweet before doing so. So logically, if we take the difference between the appearance and the disappearance of an edge we should obtain 6 hours. c(edges, nodes) %&lt;-% net edges$difference &lt;- edges$end - edges$created_at head(edges) ## # A tibble: 6 x 6 ## source target created_at n end difference ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;int&gt; &lt;dttm&gt; &lt;time&gt; ## 1 __m_per… globea… 2019-04-12 23:00:00 1 2019-04-13 05:00:00 6 hours ## 2 __m_per… tom_ca… 2019-04-12 23:00:00 1 2019-04-13 05:00:00 6 hours ## 3 _colinf… tarask… 2019-04-12 18:00:00 1 2019-04-13 00:00:00 6 hours ## 4 _colinf… vincen… 2019-04-12 18:00:00 1 2019-04-13 00:00:00 6 hours ## 5 80data barryc… 2019-04-13 02:00:00 1 2019-04-13 08:00:00 6 hours ## 6 a1purva halfre… 2019-04-13 08:00:00 1 2019-04-13 14:00:00 6 hours source target created_at n end difference __m_pereira globeandmail 2019-04-12 23:00:00 1 2019-04-13 05:00:00 6 hours __m_pereira tom_cardoso 2019-04-12 23:00:00 1 2019-04-13 05:00:00 6 hours _colinfay taraskaduk 2019-04-12 18:00:00 1 2019-04-13 00:00:00 6 hours _colinfay vincentguyader 2019-04-12 18:00:00 1 2019-04-13 00:00:00 6 hours 80data barrycnyc 2019-04-13 02:00:00 1 2019-04-13 08:00:00 6 hours a1purva halfrebel 2019-04-13 08:00:00 1 2019-04-13 14:00:00 6 hours But how would this apply to nodes? Let’s plot the distribution of the lifespans of nodes (in milliseconds): the difference between their appearance and disappearance. nodes$difference &lt;- as.numeric(nodes$end - nodes$start) hist( main = &quot;Distribution of nodes lifespan&quot;, nodes$difference ) We see that, unlike edges nodes are not all present on the graph for the same amount of time (6 hours for edges). There is a simple reason for it. If a user has tweeted at two (or more) different times in our dataset it will be present the from its first tweet to its second tweet (+ 6 hours). 13.3 Visualise To tackle the visualisation let’s bring back our rescaling functio though we will tweak it this time around because we need more precision as we add and drop nodes and edges which sit in different data frames. If we were to rescaling using the local miinimum and maximum the two tables no longer be in sync. Therefore we use the same minimum and maximum to rescale both the nodes and edges. As a reminder this is so that the nodes do not take 1.25 to come and go but rather 60 seconds (60,000 milliseconds) as specified by the t argument. #&#39; @param x Date time column. #&#39; @param t Number of milliseconds to rescale to. rescale &lt;- function(x, min, max, t){ x &lt;- (x - as.numeric(min)) / (as.numeric(max) - as.numeric(min)) x &lt;- x * t x &lt;- x + 600 return(x) } Then onto preparing the data. We do something somewhat similar to what we did previously expect we also rescale end. There was no need to do that before as there was no need to do that since nodes and edges were only appearing on the graph and not disappearing. Here is the logic we apply to rescaling both nodes and edges: Convert the date time (POSIXct) to numeric. We can then compute the minimum (see point 3 for explanation). Since the converted numeric return the number of milliseconds since the January 1st, 1970, we can remove the minimum number of milliseconds from the start time, i.e.: start - min. Then we can compute our minimum and maximum milliseconds for the rescaling function. Finally we use our rescale function passing the minimum and maximum computed at point 4. You will notice that we remove 100 milliseconds from the nodes appearance and add 400 to the node disappearance. This is to ensure that the node is present at the time any edge connected to is created, similarly, we want to make sure nodes still exist when we drop edges, so we add 400 ms to the end time. SCALE &lt;- 30000 # 60 seconds nodes &lt;- nodes %&gt;% nodes2sg() %&gt;% ungroup() %&gt;% mutate( start = as.numeric(start), # 1 end = as.numeric(end), # 1 min = min(start), # 2 start = start - min, # 3 end = end - min # 3 ) edges &lt;- edges %&gt;% mutate( id = 1:n(), created_at = as.numeric(created_at), # 1 end = as.numeric(end), # 1 min = min(created_at), # 2 created_at = created_at - min, # 3 end = end - min # 3 ) # 4 MIN &lt;- min(edges$created_at, nodes$start) MAX &lt;- max(nodes$end, edges$end) # 5 nodes &lt;- nodes %&gt;% mutate( start = rescale(start, MIN, MAX, SCALE) - 400, end = rescale(end, MIN, MAX, SCALE) + 400 ) %&gt;% select(id, label, size, start, end) edges &lt;- edges %&gt;% mutate( created_at = rescale(created_at, MIN, MAX, SCALE), end = rescale(end, MIN, MAX, SCALE) ) %&gt;% select(id, source, target, start = created_at, end) Finally onto the visualisation, we again use sg_drop_nodes and sg_drop_edges, but this time, as we want them to also disappear we also use sg_drop_nodes and sg_drop_edges. With regard to the latter functions, since we only need to remove them from the graph we just need to specify their respective ids. Then again, we can specify the x and y coordinates as well as the color of the nodes whcih we’ll base on clusters in order to make the graph look better. nodes &lt;- sg_get_layout(nodes, edges) nodes &lt;- sg_get_cluster( nodes, edges, colors = c( &quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot; ) ) ## Found # 76 clusters sigmajs() %&gt;% sg_add_nodes(nodes, start, id, label, size, color, x, y, cumsum = FALSE) %&gt;% sg_add_edges(edges, start, id, source, target, cumsum = FALSE) %&gt;% sg_drop_nodes(nodes, id, end, cumsum = FALSE) %&gt;% sg_drop_edges(edges, id, end, cumsum = FALSE) %&gt;% sg_button( c( &quot;add_nodes&quot;, &quot;add_edges&quot;, &quot;drop_nodes&quot;, &quot;drop_edges&quot; ), &quot;Launch&quot; ) Launch 13.4 Dynamic layout An issue you may observe has to do with the layout. The layout is calculated based on the full graph, but we never have the full graph on screen only a subgraph at every time step. A better way to layout the graph is to use a dynamic layout that adjusts to the visualisation as nodes and edges appear and disappear. The forceAtlas2 layout algorithm does just that. However we cannot just launch the forceAtlas2 network as we would on a static graphs. We have to update it at regular intervals. refresh &lt;- data.frame( delay = seq(1, 32000, by = 500) ) sigmajs() %&gt;% sg_add_nodes(nodes, start, id, label, size, color, cumsum = FALSE) %&gt;% sg_add_edges(edges, start, id, source, target, cumsum = FALSE) %&gt;% sg_drop_nodes(nodes, id, end, cumsum = FALSE) %&gt;% sg_drop_edges(edges, id, end, cumsum = FALSE) %&gt;% sg_force_start() %&gt;% sg_force_restart(refresh, delay) %&gt;% sg_button( c( &quot;add_nodes&quot;, &quot;add_edges&quot;, &quot;drop_nodes&quot;, &quot;drop_edges&quot;, &quot;force_start&quot; ), &quot;Launch&quot; ) Launch The reason the graph above is not running smoothly despite only showing a few tweets at a time is that it depends on some internal JavaScript functions pertaining to sigmajs that actually add nodes and edges one by one. Even though we update the graph (with sg_force_restart) only so often the browser is quickly overwhelmed by the amount of operations it has to run. We will learn more about that and remedy to it in the next chapter. "],
["performances.html", "Chapter 14 Performances 14.1 Read 14.2 Renderers 14.3 Layout", " Chapter 14 Performances The graphTweets has already seen great performance improvements and can now build large graphs. The sigmajs library needs some explanation, namely on layout, and renderers. 14.1 Read You might have noticed that we reduced the number of tweets we visualised in the last four chapters, fetching only 400 odd tweets. This is because dynamic graphs are quite draining for the website (more on that later in the chapter). There is however a remedy to it, or part of it anyway. Instead of using sg_add_nodes and sg_add_edges we can use the sg_read_* family of functions. We’ll collect some tweets setting type as mixed to ensure we get tweets that spread over a couple of days. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats&quot;, n = 3500, token = TK, include_rts = FALSE, type = &quot;mixed&quot;) ## Searching for tweets... ## Finished collecting tweets! With the tweets we collected we’ll build a dynamic network where nodes and edges appear on the day they are created. graph &lt;- tweets %&gt;% gt_edges(screen_name, mentions_screen_name, created_at) %&gt;% gt_nodes() %&gt;% gt_dyn() %&gt;% gt_collect() c(edges, nodes) %&lt;-% graph we’ll start by changing the created_at from a datetime to a date then a numeric. Also, for a change, we’ll rescale with the scales package (???) to rescale the nodes and edges date of appearance, the scales package makes it much more convenient. You can install scales from CRAN with install.packages(“scales”) Note that we also scales package to color the nodes according to their size. One additional thing, remember how, if not specified, sg_nodes randomly assigns coordinates? Perhaps we ought to initialise x and y in a circle to make the visualisation visually more appealing; it’ll make the nodes appear from the outer edges of the graph. nodes &lt;- nodes %&gt;% sg_get_layout(edges, layout = igraph::layout_in_circle) %&gt;% # get coordinates dplyr::arrange(start) %&gt;% dplyr::mutate( start = as.Date(start), start = as.integer(start), start = scales::rescale(start, to = c(1, 10000)), size = n, color = scales::col_numeric(c(&quot;#0075a0&quot;, &quot;#c0deed&quot;), domain = NULL,)(start) ) edges &lt;- edges %&gt;% dplyr::arrange(created_at) %&gt;% dplyr::mutate( created_at = as.Date(created_at), created_at = as.integer(created_at), created_at = scales::rescale(created_at, to = c(1, 10000)), id = 1:dplyr::n() ) Now that nodes and edges are ready we can use our new functions, rest assured they work in very much the same way. Finally we’ll add a date tracker with sg_progress as we have done in previous chapters. progress &lt;- tweets %&gt;% dplyr::mutate(created_at = as.Date(created_at)) %&gt;% dplyr::distinct(created_at) %&gt;% dplyr::arrange(created_at) %&gt;% dplyr::pull(created_at) %&gt;% dplyr::tibble( date = ., delay = unique(nodes$start) ) %&gt;% dplyr::mutate(text = format(date, &quot;%d %b&quot;)) sigmajs() %&gt;% sg_force_start() %&gt;% sg_read_nodes(nodes, id = nodes, size, color, x, y, delay = start) %&gt;% sg_read_edges(edges, id, source, target, delay = created_at) %&gt;% sg_read_exec() %&gt;% sg_force_stop(11000) %&gt;% sg_progress(progress, delay, date, position = &quot;bottom&quot;) %&gt;% sg_button(c(&quot;read_exec&quot;, &quot;force_stop&quot;, &quot;progress&quot;), &quot;Add nodes and edges&quot;) %&gt;% sg_settings( minNodeSize = 1, maxNodeSize = 4, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#d3d3d3&quot; ) Add nodes and edges 14.2 Renderers The sigmajs package actually comes with three renderers out-of-the-box; canvas, the default, svg and webgl. svg makes for slightly nicer looking graphs but at performance costs so only use it for the smaller graphs. In contrast, webgl is extremely performant. Let’s plot huge graph using webgl to demonstrate, below we graph 25,000 nodes. data &lt;- sg_make_nodes_edges(25000) # make 25,000 nodes sigmajs(&quot;webgl&quot;) %&gt;% # set to webgl sg_nodes(data$nodes, id, size) %&gt;% sg_edges(data$edges, id, source ,target) %&gt;% sg_layout() %&gt;% sg_settings( nodeColor = &quot;default&quot;, defaultNodeColor = &quot;#328983&quot;, edgeColor = &quot;default&quot;, defaultEdgeColor = &quot;#b9b9b9&quot; ) 14.3 Layout As you might have observed in the previous chapter on ephemeral graphs our last graphs is not layed out quite as nicely as we would like to. How forceAtlas2 works in sigmajs When you pass sg_force or sg_force_start to your graph, on load (or on the button click, if linked), forceAtlas2 kicks in and starts to layout the graph. We saw that since this is draining the browser we can then pass sg_force_stop specifying a delay in milliseconds when we want the layout to stop. What happens when we actually run the above but adding or dropping nodes or edges? In actual fact the layout does not run constantly, as it would not take into account added or dropped nodes or edges and would continue running as if new edges or nodes were not added. Therefore a worker is created and the forceAtlas2 layout is killed then started after every node and or edge is added or dropped. This can be quite difficult for the browser to handle. Let’s make a dummy example below to show how it works smoothly for the smaller graphs. nodes &lt;- sg_make_nodes(colors = c(&quot;#0084b4&quot;, &quot;#00aced&quot;, &quot;#1dcaff&quot;, &quot;#c0deed&quot;)) edges &lt;- sg_make_edges(nodes) # add random delay between .5 and 2 seconds edges$delay &lt;- runif(nrow(edges), 500, 1000) sigmajs(height = 300) %&gt;% sg_force_start() %&gt;% sg_nodes(nodes, id, size, color) %&gt;% sg_add_edges(edges, delay, id, source, target, refresh = TRUE) %&gt;% # read delay documentation sg_button(c(&quot;add_edges&quot;), &quot;Add edges&quot;) %&gt;% sg_settings( mouseEnabled = FALSE, touchEnabled = FALSE, minNodeSize = 1, maxNodeSize = 4 ) Add edges The above is much less draining on the browser and runs smoothly. "],
["rmd.html", "Chapter 15 R markdown 15.1 Buttons 15.2 Delays", " Chapter 15 R markdown This chapter covers R markdown-specific functions of the twinetverse. We’ve actually covered a few of those already, rtweet and graphTweets do not have functions specifically meant to be used in R markdown, all work just as well in a interactive and non-interactive environments. The dynamic nature of sigmajs, however, suggests the intriduction of additional functions. # TK &lt;- readRDS(file = &quot;token.rds&quot;) tweets &lt;- search_tweets(&quot;#rstats filter:mentions&quot;, n = 1000, token = TK, include_rts = FALSE) 15.1 Buttons One of the functions of the sigmajs package that we have already covered enables adding buttons to make trigger events in sigmajs: sg_button. These events need to be tied to the visualisation, the button (sg_button) is only the trigger. Most events can be used without triggers, events that cannot just be used on their own are exports: export_svg and export_img. The events are simply the name of the function (event) they trigger without the starting sg_, i.e.: export_svg event triggers sg_export_svg. Let’s illustrate the above example. We first draw a graph. sigmajs() %&gt;% sg_nodes(nodes, id, size, color) %&gt;% sg_edges(edges, id, source, target) Then add the event and the corresponding button. sigmajs() %&gt;% sg_nodes(nodes, id, size, color) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_force_start() %&gt;% sg_button(&quot;force_start&quot;, &quot;Start&quot;) Start Below are the events that can be tied to buttons. force_start force_stop noverlap drag_nodes relative_size add_nodes add_edges add_nodes_edges drop_nodes drop_edges animate export_svg export_img 15.2 Delays some functions of the sigmajs package take a delay argument, which, though can be used in any way or framework (shiny, R markdown, etc.), it is specifically designed with R markdown in mind. Take for instance the layout algorithm and button we used above; as you read this it is still running, which is draining for the browser and useless as the layout has stabilised. We could do the inverse of what we do above, of course, trigger the layout on page load and instead provide a button for the user to stop the layout. However, what would be ideal is for the layout to simply stop after a few seconds. Let’s implement the latter. nodes &lt;- sg_get_layout(nodes, edges) sigmajs() %&gt;% sg_nodes(nodes, id, size, color, x, y) %&gt;% sg_edges(edges, id, source, target) %&gt;% sg_force_start() %&gt;% sg_force_stop(10000) We removed the button as we just trigger the layout algorithm when the page loads then we pass sg_force_stop specifying that we want the force layout to stop after 10,000 milliseconds (10 seconds). "],
["references.html", "References", " References "]
]
